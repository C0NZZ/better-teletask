WEBVTT

00:01.600 --> 00:10.192
So, ich darf Sie herzlich begrüßen zur Komplexitätstheorie, unsere Vorlesung, Einführung in die Komplexitätstheorie.

00:10.232 --> 00:18.384
Wir haben damit ein Thema der theoretischen Informatik vor Auge.

00:18.404 --> 00:30.882
In der ersten Vorlesung heute will ich einen groben Überblick geben über das Programm der Vorlesung, will in bestimmte Motivationen liefern und dann bei der tähnsten Vorlesung wird das dann richtig in Stoff gehen.

00:32.380 --> 00:34.972
Also was ist Komplexitätstheorie, womit beschäftigt die sich?

00:35.675 --> 00:41.462
Zunächst mal hatte ich schon gesagt, es ist ein Kerngebiet der theoretischen Informatik.

00:42.978 --> 00:51.715
Dieses Thema Komplexitätstheorie ist sehr eng verbunden mit einem weiteren Gebiet der theoretischen Informatik.

00:51.735 --> 00:59.629
Das ist nämlich das Gebiet effiziente Algorithmen, Entwurf effizienter Algorithmen und Analyse effizienter Algorithmen.

00:59.670 --> 01:03.096
Diese Vorlesung haben Sie gehört.

01:03.076 --> 01:11.548
haben Sie gehört in Formatik 2, sodass Sie also mit der Thematik vertraut sind.

01:11.588 --> 01:24.586
Es sind dabei auch, als Sie das besprochen haben, auch Themen angesprochen worden zur Komplexitätstheorie, nämlich in dem Moment, wenn Sie analysiert haben die Algorithmen und das soll jetzt hier vertieft werden.

01:24.647 --> 01:26.890
Also, was macht die Komplexitätstheorie?

01:26.910 --> 01:32.037
Die Komplexitätstheorie lotet die Grenzen des Algorithmisch-Machbaren aus.

01:32.945 --> 01:46.804
Wenn Sie also ein Problem haben und um dessen Lösung ringen, Algorithmen entwerfen, am Ende dann ein Programm entwerfen wollen, was dieses Problem löst, dann ist die Frage, wie viele Ressourcen brauchen Sie?

01:46.824 --> 01:50.348
Nun ist das die erste Frage, die man stellen muss, was sind denn Berechnungsressourcen?

01:50.368 --> 01:56.016
Sofort fallen einem natürlich die Zeit, die Rechenzeit, sofort fallen einem einen Speicherbedarf.

01:55.996 --> 02:01.545
Aber auch die Ressource, wie groß ein Schaltkreis sein muss, der das Problem löst, ist klar.

02:01.565 --> 02:07.655
Wie viele Kommunikation, wie viele Bits ausgetauscht werden müssen, wenn verschiedene Partner das Problem lösen.

02:07.675 --> 02:10.619
Das sind alles Berechnungsressourcen.

02:10.639 --> 02:16.789
Und die Komplexitätstheorie, die versucht, den Mindestressourcen bedarf zu bestimmen.

02:16.769 --> 02:27.471
Also wenn Sie ein Problem vorgegeben haben und Sie interessieren sich für die Lösung des Problems, ist die Frage, was müssen Sie bereitstellen an Computerressourcen, damit das Problem überhaupt lösbar ist?

02:28.328 --> 02:42.402
So nun kann einer da irgendwie ein furchtbar unstrukturiertes und uneffizientes Programm schreiben und sie müssen viele Ressourcen hinstellen, damit das Programm läuft, obwohl das Problem sehr viel mit einem besseren Algorithmus sehr viel effizienter löstbar wäre.

02:42.442 --> 02:56.597
Also die Komplexitätstheorie interessiert sich nicht einfach dafür, wann ist das Problem machbar, wann ist es löstbar, wenn ich so und so viele Ressourcen zur Verfügung stelle, sondern die Komplexitätstheorie interessiert sich dafür, was muss ich denn mindestens zur Verfügung stellen?

02:57.708 --> 03:07.305
Und das ist eine Frage, die sich sowohl auf ein einzelnes Problem als auch auf eine ganze Problemklasse bezieht.

03:07.345 --> 03:12.133
Also Sie sehen, die effizienten Algorithmen, die kommen mit Lösungen, die kommen im Algorithmus an.

03:12.173 --> 03:21.049
Hier in der Komplexitätstheorie wollen wir versuchen zu sehen, was muss ich denn bereitstellen, damit das Problem algorithmisch lösbar ist.

03:22.227 --> 03:38.307
Und die Frage wird insbesondere dann interessant, wenn man noch gar keine richtige Lösung für ein Problem hat, wenn man also anfängt ein Problem zu lösen, wenn man sagt, Mensch, mit was für Algorithmen, was muss ich denn rechnen, um dieses Problem zu lösen?

03:38.327 --> 03:42.953
Also, hier gibt es einen unterschiedlichen Ansatz, ein Ansatz aus dem Bereich effizienter Algorithmen.

03:43.743 --> 03:46.153
und einen Ansatz aus dem Bereich Komplexitätstheorie.

03:46.173 --> 03:49.606
Sie werden sehen, das sind die verschiedenen Seiten der gleichen Medaille.

03:49.626 --> 03:54.867
Also wie ist der Ansatz bei dieser Sichtentwurf effizienter Algorithmen?

03:56.011 --> 04:03.419
Dort hat man ein Problem und versucht dann ein Algorithmus zu entwerfen, der möglichst gut ist.

04:03.439 --> 04:07.003
Jetzt habe ich das in Anführungsstrichen gesetzt, was gut heißt.

04:07.023 --> 04:09.105
Das können nämlich ganz verschiedene Dinge sein.

04:09.125 --> 04:17.094
Das kann sein, wenn bei Ihnen das ein Online-Problem ist, ein Real-Time-Problem ist, dann heißt es gut, es soll möglichst schnell gelöst werden.

04:17.134 --> 04:20.298
Der Algorithmus soll in möglichst kurzer Zeit die Ergebnisse liefern.

04:21.079 --> 04:25.984
Wenn Sie den Algorithmus nur auf einem kleinen mobilen Gret

04:26.082 --> 04:34.058
laufen lassen können, also für unterwegs Navigationssystem irgendwas, dann ist wahrscheinlich das Speicher der Flaschenhals.

04:34.078 --> 04:40.911
Dann geht es darum, den guten Algorithmus zu bauen so, dass er möglichst wenig Speicher braucht.

04:40.951 --> 04:49.688
Also was gut ist, muss genauer geklärt werden und das wird, haben Sie ja gemacht im Bereich der effizienten Algorithmen, auch in der Komplexitätstheoriebereich, werden wir das machen.

04:49.728 --> 04:53.676
Es ist nicht der gute Algorithmus, sondern es gibt verschiedene Optimierung,

