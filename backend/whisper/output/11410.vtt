WEBVTT

00:00.031 --> 00:05.240
Ich begrüße Sie im Wintersemester 2025-2026.

00:05.280 --> 00:10.268
Sie haben das jetzt im dritten Semester vor sich, diese Veranstaltung.

00:10.288 --> 00:14.135
Das heißt, Sie haben ein bisschen HPI schon erlebt.

00:14.155 --> 00:16.639
Diesmal soll es um Betriebssysteme gehen.

00:17.311 --> 00:19.654
Pflichtveranstaltung, schon klar.

00:19.674 --> 00:21.916
Gibt einen Teil eins, gibt einen Teil zwei.

00:21.976 --> 00:28.783
Und ... Sie kommen in den Genuss einer komplett überarbeitenden Vorlesung.

00:28.843 --> 00:31.647
Und zwar ... das ist neu.

00:31.667 --> 00:39.535
Mit Rückmeldung und ganz viel Engagement und Input von Studierenden aus den letzten Semestern.

00:39.575 --> 00:41.878
Da ist Daniel Guzic und Joris Funk zu nennen.

00:41.918 --> 00:44.020
Joris ist hier.

00:44.040 --> 00:46.002
Daniel, ich weiß nicht, ob es so anders ...

00:45.982 --> 00:53.050
Und natürlich ist Clemens Tietz zu nennen, Doktorantin meiner Gruppe, mein Name Andreas Polze.

00:53.070 --> 00:54.034
Worüber reden wir?

00:55.803 --> 01:04.035
Also erst mal möchte ich heute so ganz grob in einem Schnelldurchlauf darüber sprechen, was in dieser Lehrveranstaltung dran kommt.

01:04.055 --> 01:06.539
Das gibt eine Vorgeschichte von diesem Groß.

01:06.579 --> 01:09.142
Wir fragen uns mal, was soll ein Betriebssystem überhaupt sein?

01:09.282 --> 01:10.024
Wofür braucht man das?

01:10.044 --> 01:11.005
Muss man das überhaupt haben?

01:11.045 --> 01:15.752
Warum sollen Sie das wissen, was jetzt hier erzählt wird?

01:15.772 --> 01:17.254
Und die Antwort ist ganz einfach.

01:18.517 --> 01:26.908
Sie werden wahrscheinlich ohne dieses Wissen durch die Welt kommen, solange Sie auf dem Handy rumklicken oder eine Web-Applikation programmieren.

01:26.928 --> 01:45.233
Wenn Sie aber irgendwann in die Situation kommen, dass Ihre Software nicht schnell genug läuft, dass der Rechner zu langsam ist, nicht genug Speicher hat, aus irgendeinem Grund die Platte nicht aufwärts zu drehen oder überhaupt die Kosten zu hoch sind, dann wollen Sie sich erinnern an das, was Sie hier gehört haben.

01:45.213 --> 01:51.846
Also das ist nicht eine Sache, die man unbedingt täglich braucht, um zu überleben.

01:51.907 --> 01:58.881
Aber früher oder später werden sie sich alle mit Betriebssystemen beschäftigen müssen, wenn sie in der Informatik weiterhin unterwegs sind.

02:01.085 --> 02:02.207
Es gibt ein paar Beispiele.

02:02.268 --> 02:04.993
Es gibt eine These, das ist auf der Welt.

02:05.075 --> 02:08.925
Raum für fünf Computer gibt, hat jemand das schon mal gehört.

02:08.945 --> 02:17.127
Das war von Thomas Wotzin, damals IBM-Vorsitzender oder Sherperson in den 1930er Jahren.

02:25.055 --> 02:26.998
Okay.

02:27.018 --> 02:30.322
Und gemeint waren natürlich die Supercomputer zu dieser Zeit.

02:30.342 --> 02:37.351
Wer die Nachrichten verfolgt hat, gerade wurde in Jülich so ein Supercomputer für Deutschland in Betrieb genommen.

02:37.371 --> 02:48.666
Der Bundeskanzler war da, derselbe Bundeskanzler, der nebenbei heute das HPI besucht und gestern noch in Gaza war, in Scharmel-Scheich, also ich möchte auch kein Bundeskanzler sein.

02:50.772 --> 02:57.364
Super Computer, das sind solche, die sozusagen das obere Ende der Fahnenstange darstellen.

02:57.385 --> 03:02.574
Und davon gibt es halt wirklich nur wenige, weil man sich das nicht leisten will.

03:02.614 --> 03:10.890
Und bei solchen Rechnern, da steht eine Frage im Mittelpunkt, nämlich wie kann man diesen Computer effizient auslasten, so effizient wie möglich.

03:10.870 --> 03:26.134
Das ist eine Frage, die wir in den Standardsystemen, Desktop-Computern, in ihrem Notebook uns heute nicht mehr so stellen, weil wir sagen, die Produktivität des Benutzers steht vorne dran und die Produktivität des Programmierers und dann kommt noch die KI mit Chatchi-BT und so weiter.

03:26.194 --> 03:38.633
Aber wenn Sie dann ein bisschen weitergucken und mal an Ihre Waschmaschine denken oder an Ihr Auto oder an den ICE, mit dem Sie fahren, dann stellen Sie fest, da kommen wieder Computer vor, bei denen die Effizienz der Computer ganz weit vorne steht.

03:39.237 --> 03:50.292
weil sie nur so wenig Speicher einbauen wollen, weil sie garantieren müssen, dass das ABS im richtigen Moment bremst, weil sie verstehen müssen, was da an Software läuft.

03:50.312 --> 04:00.026
Und da ist auch nichts mehr mit KI, sondern da muss man wirklich formale Beweise führen, dass ein Programm in der richtigen Zeit fertig wird.

04:00.066 --> 04:04.372
Haben Sie schon mal vom Halte-Problem für Turing-Maschinen gehört?

04:04.392 --> 04:04.452
Ja?

04:06.862 --> 04:10.285
Okay, wenn nicht, dann googeln Sie mal.

04:10.305 --> 04:14.289
Nicht, jetzt wurden gerade Nobelpreise verliehen.

04:14.329 --> 04:23.837
Wenn Ihnen jemand sagt, Sie sollen sich anstrengen, damit Sie den Nobelpreis für Informatik bekommen, dann drehen Sie sich um und gehen einfach weg, weil der Mensch hat überhaupt nichts verstanden.

04:23.857 --> 04:28.581
Es gibt keinen Nobelpreis für die Informatik, sondern es heißt Turing Award in unserer Branche.

04:28.661 --> 04:35.147
Und Alan Turing hat gezeigt, dass man beweisen kann, dass

04:36.663 --> 04:42.990
nicht klar ist, ob im nächsten Schritt das Programm terminiert oder ob es noch ewig weiterrechnet.

04:43.010 --> 05:02.974
Das heißt, wenn Sie algorithmisch vollständige Programme betrachten, also zum Beispiel ein E-Mail-Programm oder Word oder auch eben eine Steuerungssoftware fürs Space Shuttle, dann können Sie diesen Programm nicht ansehen, ob es Programmierfehler enthält, endlos schleifen, ob es niemals aufhört.

05:04.355 --> 05:10.604
Manchmal möchten Sie aber garantieren, dass das AWS richtig bremst im Auto.

05:10.624 --> 05:14.029
Also da gibt es offenbar eine Schwierigkeit.

05:14.309 --> 05:16.473
Und die Frage ist, wie löst man das auf?

05:16.493 --> 05:20.078
Das ist auch ein Thema, wo Betriebssysteme auf einmal wieder in der Rolle spielen.

05:20.098 --> 05:23.182
Also auf Deutsch, das wird schon noch spannend hier.

05:23.963 --> 05:26.347
Wir unterhalten uns ein bisschen darüber, was ein Computer eigentlich ist.

05:26.367 --> 05:29.992
Rechenarchitektur, da haben Sie beim Holger Karren eine ganze Menge gehört.

05:30.012 --> 05:34.058
Und was für Umgebungen gibt es denn, in denen wir Computer einsetzen?

05:36.198 --> 05:40.103
Wer wir sind, mein Fachgebiet, Betriebssystem und Mittelwehr.

05:40.163 --> 05:42.847
Ich bin hier am HPE seit 2001.

05:42.887 --> 05:49.396
Wir unterhalten uns letztlich über verteilte Systeme, über weitverteilte Systeme, über Cloud Computing.

05:49.416 --> 05:53.521
Wir unterhalten uns aber auch über ressourcenbeschränkte Systeme.

05:53.541 --> 05:56.926
Wir haben aktuell drei große Felder, in denen wir arbeiten.

05:56.966 --> 05:59.269
Das ist mit der Deutschen Bahn.

05:59.309 --> 06:03.555
Da geht es um Digitalisierung im Bahnbetrieb, Leitung, Sicherungstechnik, Stellwerke usw.

06:03.856 --> 06:05.939
Wir sind mit der IBM Zugange.

06:05.959 --> 06:07.842
Die IBM hat in Böbling ein Labor.

06:07.862 --> 06:09.043
Dieses Labor gibt es seit 1952.

06:09.063 --> 06:12.608
Da war der Begriff Informatik noch nicht geprägt.

06:12.628 --> 06:16.814
Dort wird heute immer noch Rechenarchitektur betrieben und Prozessoren entworfen.

06:16.834 --> 06:21.380
Die Power-Systeme und die sogenannte Z-Series.

06:21.400 --> 06:25.065
Und ein Drittes Feld, in dem wir eine ganze Zeit aktiv waren, aktuell nicht mehr so doll.

06:25.085 --> 06:26.748
Das ist die Telemedizin.

06:26.768 --> 06:30.673
Da haben wir unter anderem dazu beigetragen,

06:30.991 --> 06:36.965
Rannenburg oder überhaupt bei der AOK heute in der Regelversorgung telemedizin verordnet werden kann.

06:36.985 --> 06:45.304
Das heißt Menschen, die im ländlichen Raum sind mit schlechten Zugang zu Ärzten, die können sich da sozusagen

06:46.128 --> 06:50.396
angucken lassen durch einen Telemedizinzentrum und ihre Daten dorthin regelmäßig übertragen.

06:51.057 --> 06:53.922
Clemens Tied, wie gesagt, Dr. Randt in meiner Gruppe.

06:53.942 --> 06:57.468
Dessen Thema, na ja, Rast, das werden Sie schon ermerken.

06:57.488 --> 07:02.698
Und zum anderen geht es um Energiegewares rechnen.

07:02.738 --> 07:08.608
Wenn Sie sich nämlich in den Computer angucken und gerade heute die KI-Systeme, dann können Sie sich fragen,

07:08.588 --> 07:12.713
Ab wann ist denn der Einsatz von Computern unethisch?

07:13.213 --> 07:23.205
Sie haben vielleicht davon gehört, dass Google heute anfängt, Mini-Atomkraftwerke zu designen, um den Energiehunger zu füttern für diese KI-Systeme.

07:23.225 --> 07:26.088
Man redet darüber, dass Phillipsburg wieder in Betrieb geht.

07:26.128 --> 07:33.837
Phillipsburg, lange wahrscheinlich vor ihrer Zeit, war das erste Atomkraftwerk, in dem man so einen Supergrau erlebt hat, wie zum Schluss in Fukushima.

07:33.817 --> 07:42.332
Aber das will man wieder ans Netz bringen, ist bei Philadelphia in den USA.

07:42.352 --> 07:44.400
Und der Hintergrund

07:46.523 --> 07:52.628
Bei KI-Systemen, da gibt es keinen definierten Algorithmus, der sagt, am Ende sind wir fertig.

07:52.649 --> 07:58.073
Sondern sie können immer noch ein bisschen weiter lernen, sie können immer noch ein bisschen mehr optimieren.

07:58.194 --> 08:05.940
Und das ist sozusagen der schlimmste Fall für ein Computer, was Energieeinsatz angeht.

08:06.021 --> 08:11.465
Und na ja, dagegen kann man was tun, indem man sich zum Beispiel fragt, was kann ich denn abschalten in einem Computer?

08:11.485 --> 08:13.627
Also, wo geht denn eigentlich der ganze Strom hin?

08:13.647 --> 08:16.530
Wie groß ist denn eigentlich das Netzteil in dem Computer, den Sie zu Hause haben?

08:16.510 --> 08:20.218
500 Watt oder mehr?

08:20.438 --> 08:23.484
Ja, das sind die Spieler.

08:23.524 --> 08:29.136
So ein Notebook-Netzteil nicht, das geht mit 60 Watt durch, aber wo gehen die 500 Watt hin?

08:32.103 --> 08:34.149
40 Prozent gehen in den Speicher.

08:34.169 --> 08:37.738
Der Speicher in einem Computer, das ist so, als wenn sie Wasser mit einem Sieb tragen wollen.

08:37.778 --> 08:40.766
Das läuft immer durch und sie müssen fortwärts Neues reinfüllen.

08:40.826 --> 08:46.602
Weil diese D-Ram-Zellen nicht, das sind halt Kondensatoren, die immer wieder geladen werden müssen.

08:47.172 --> 08:51.737
Selbst wenn der Computer gar nichts macht, verbraucht er 40 Prozent seiner Energie.

08:51.757 --> 08:54.240
Wenn er anfängt zu rechnen, wird es noch mal schlimmer.

08:55.441 --> 08:57.944
Sie haben vielleicht schon mal vom KI-Servicezentrum gehört.

08:57.984 --> 09:04.391
Das ist eines von vier deutschlandweit betriebenen Zentren, wo der Mittelstand irgendwie KI lernen soll.

09:04.411 --> 09:06.393
Das existiert hier am HPI.

09:06.413 --> 09:10.277
Dort haben wir sogenannte GPU-Maschinen.

09:10.730 --> 09:17.929
Das sind DJI-X1 von NVIDIA, so kleine Silberkisten, also wirklich tatsächlich so groß.

09:18.370 --> 09:26.511
Ein Schub im Regner und eine so eine Kiste hat eine Anschlussleistung von 4,8 Kilowatt im Eile-Modus.

09:26.592 --> 09:33.281
Bloß mal so zum Einschätzen, wenn Sie im Einfamilienhaus groß geworden sind, das können Sie mit fünf KW heizen.

09:33.301 --> 09:35.884
Wenn Sie einen Kamin haben, der hat eine Leistung von fünf KW.

09:35.904 --> 09:43.974
Also stellen Sie sich vor, da steht so ein Kawin und davon gibt es aber nicht ein, sondern vier übereinander und davon gibt es nicht einen Strang, sondern drei nebeneinander.

09:43.994 --> 09:45.336
Also das ist, was KI bedeutet.

09:45.376 --> 09:50.963
Da geht immens Energie rein und muss man sich mit auseinandersetzen.

09:52.124 --> 09:56.852
Joris Fung hatte ich schon genannt, der hat im letzten Jahr den Kurs gemacht hier, oder?

09:56.932 --> 10:05.167
Und Daniel Gussitz, der dort ganz stolz des Buchs mit dem Rast zeigt, auch cool.

10:05.187 --> 10:08.833
Und dann haben wir noch Sebastian, oder?

10:09.910 --> 10:21.228
Das kommt auch noch vor.

10:21.248 --> 10:24.053
Das müssen wir vielleicht mal bei Gelegenheit drüber reden.

10:24.073 --> 10:27.278
Wir haben ja hier Vorlesungen.

10:29.114 --> 10:30.917
Wir machen so ein 3 plus 1 Modell.

10:30.937 --> 10:32.399
Sie hören immer drei Vorlesungen.

10:32.419 --> 10:35.865
Nehmen wir, wir zeichnen die Vorlesung auf, auf TeleTask.

10:35.905 --> 10:42.636
Ich mache das ungern, aber es ist beim Spezirenden beliebt.

10:42.677 --> 10:44.920
Ich sage immer, was passieren wird.

10:44.940 --> 10:52.273
Sie werden sich das hier anhören, und dann werden sie sagen, oh, diese technische, ne, theoretische Informatik ist wichtiger.

10:52.293 --> 10:54.396
Die Mathematik strengt mich mehr an.

10:55.051 --> 10:58.215
Das Zeug kann ich mir hinterher noch im Fernsehen angucken.

10:58.235 --> 11:01.920
Ich komme nicht mehr zur Vorlesung.

11:01.940 --> 11:05.404
Also, kommen Sie halt trotzdem, wenn Sie es schaffen.

11:05.485 --> 11:09.069
Und wenn nicht, dann bin ich es nicht anders gewohnt.

11:09.089 --> 11:11.312
Das Ganze ist so wie die Droge auf dem Schulhof.

11:11.332 --> 11:17.380
Wenn man einmal angefangen hat, dann muss man immer weitermachen, weil man natürlich Unfug erzählt.

11:18.710 --> 11:29.781
Irgendwann werde ich hier irgendwie unkorrekte Witze machen oder ich werde einfach falsche Sachen erzählen und das ist dann halt hübsch im Band aufgenommen bei TeleTask.

11:29.801 --> 11:32.904
Haben Sie TeleTask schon mal angeklickt?

11:32.924 --> 11:34.045
Wenn nicht, machen Sie das mal.

11:34.085 --> 11:37.669
Also tele-task.de ist ganz interessant.

11:37.689 --> 11:47.839
Da gibt es viele Vorlesungsaufzeichnungen und ja, ich kann es komplett verstehen, dass man manchmal andere Sachen machen muss und dann gucken Sie es halt hinterher an.

11:49.928 --> 11:53.412
Wir haben allerdings eine kleine Abhängigkeit eingebaut.

11:53.452 --> 11:59.560
Man muss schon den Vorlesungsstoff sich anschauen oder mitnehmen oder sich zuführen.

11:59.620 --> 12:06.449
Wenn man die Übung machen will, die Übung muss man machen, damit man für die Prüfung eine Zulassung kriegt.

12:07.270 --> 12:13.117
Und Übungsbetrieb läuft bei uns so, da gibt es halt jeder dritte, jeder vierte Termin mehr oder weniger ist ein Übungstermin.

12:13.157 --> 12:17.623
Wir gucken da ein bisschen in den Stoff rein, wo es gerade passt und wir gucken auch in unsere Kalender, weil wir

12:17.975 --> 12:22.362
unter anderen auch andere Termine noch haben.

12:22.422 --> 12:26.669
Und dort werden dann Dinge noch mal nachgearbeitet.

12:26.689 --> 12:29.413
Dort gibt es dann auch ein Querbezug zu anderen Betriebssystemen.

12:29.433 --> 12:34.261
Die Veranstaltung hier, die stützt sich nämlich stark auf das Windows-Betriebssystem ab.

12:34.281 --> 12:35.663
In Übungen gibt es dann Linux.

12:37.077 --> 12:41.004
Und in den Übungen wird es auch über das Thema programmieren geredet.

12:41.024 --> 12:46.994
Da kommt dann neben C auch Rast vielleicht ein bisschen zur Sprache, wollen wir mal sehen.

12:47.035 --> 12:48.076
Und dann gibt es die Übungsaufgaben.

12:48.116 --> 12:59.777
Und die Übungsaufgaben, und deshalb kommen diese vier Namen, Mik als Vertreter, aber eben auch der Mathis und Sebastian und Konstantin ins Spiel.

12:59.757 --> 13:03.021
Sie werden sich zu Gruppen zusammenfinden müssen, zu zweit oder zu dritt.

13:03.061 --> 13:07.446
Und dann werden Sie als Übungsgruppe Ihrem Tutor erklären müssen, wie die Lösung geht.

13:08.608 --> 13:11.891
Das heißt, wenn Sie den Tutor erklären, ich habe mir das von Shatchi B.T.

13:11.912 --> 13:16.497
generieren lassen, dann wird der sagen, passt nicht.

13:16.557 --> 13:25.748
Und wenn einer oder eine nichts sagt, dann wird diese Person vielleicht nochmal separat aufgefordert zu erklären, wie die Lösung zustande gekommen ist.

13:25.728 --> 13:28.412
Das ist ein Schema, was ich über die Zeit bewährt habe.

13:28.452 --> 13:30.115
Das skaliert ganz gut.

13:30.135 --> 13:36.344
Sie kriegen genug Feedback über die Zeit und damit sind sie dann auch gewappnet für alles.

13:36.364 --> 13:42.012
Also lässt sich auch für die Klausur.

13:42.032 --> 13:52.528
Wenn Sie gucken, was für Klausuren so rumfahren, ich glaube die neueste, die publik ist, die ist so von 2018, müssen Sie sich in Ihren Studentennetzwerken mal verraten.

13:57.571 --> 14:01.603
Die Uni wird immer bürokratischer.

14:01.623 --> 14:07.902
Sie müssen sich selber für die Klausur anmelden über das CMS.

14:14.665 --> 14:17.869
kriegen Sie hin.

14:17.889 --> 14:21.153
Sie müssen halt die Übungen mit ihrem Tutor besprechen.

14:21.173 --> 14:23.336
Überhaupt sind die ganzen Folien auf Englisch.

14:23.356 --> 14:25.800
Ich werde hier aber trotzdem Deutsch reden.

14:25.840 --> 14:41.500
Das ist im Bachelor so üblich, wenn Sie ... Wenn Sie eine andere Sprache bestellen, dann könnte ich aus der Englisch noch russisch anbieten, aber machen wir einfach nicht.

14:44.922 --> 14:53.473
Zur Vorgeschichte, der Kurs, der ist irgendwann mal entstanden, das war so um die 2000 herum in der Kooperation mit Microsoft.

14:53.493 --> 14:59.180
Und damals war die Frage, wie kann man eigentlich über Windows als Betriebssystem reden?

14:59.880 --> 15:12.516
Nicht Junix, das haben Sie vielleicht schon mitbekommen, ist in den 1970er Jahren entstanden und ET&T, also die amerikanische Telefongesellschaft, hatte die Quellen und hat relativ frühzeitig die Quellen rausgegeben.

15:12.496 --> 15:29.897
überhaupt war es früher üblich, dass man Quellen zu Betriebssystemen mit raus gab und sowohl wir hier in Potsdam als auch die Humboldt in Berlin, wo ich vorher war, wir hatten halt eine Quellgut-Lizenz von AT&T und damit war Junix in einer Vorlesung gesetzt, konnte man gut darüber reden, einfach.

15:29.877 --> 15:32.700
Es wurde ein bisschen aufregender, als da ein Linux ins Feld kam.

15:32.720 --> 15:34.362
Linux habe ich erlebt, das erste Mal 1991.

15:34.382 --> 15:39.148
Damals kam das irgendwie auf drei Disketten.

15:39.188 --> 15:43.152
Und inzwischen ist halt viel mehr, gibt es viele Distributionen.

15:43.193 --> 15:45.796
Das Problem bei Linux ist ein bisschen, ist nicht Fisch und nicht Fleisch.

15:45.836 --> 15:53.244
Also es ist, wenn man die Geschichte anguckt, steht es so zwischen den Systemen.

15:53.264 --> 15:59.091
Auf der anderen Seite ist es heute im Serverbetrieb gesetzt und ist das Betriebssystem, mit dem man sich auseinandersetzen muss.

15:59.493 --> 16:05.851
Und dann haben sie vielleicht schon mal von der ACM gehört, der Association of Computing Machinery.

16:05.871 --> 16:14.616
Und vom IEEE, das ist der Verband der Elektroingenieure, die haben sich hingesetzt und haben gesagt, wir wollen mal standardisieren, was man über Betriebssysteme wissen muss.

16:14.596 --> 16:24.042
Dann haben sie das OSBock gebaut, den Body of Knowledge und da gibt es halt Pflichtmodule und Elective Units.

16:24.063 --> 16:29.618
Und man muss fünf von den Pflichtmodulen machen, Prinzipien, Nebenläufigkeit, Speicherverwaltung.

16:29.598 --> 16:51.302
Und, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um, um,

16:51.282 --> 16:56.170
die für Sie wirklich im späteren Leben definitiv relevant sind.

16:56.190 --> 17:02.781
Wer Spaß hat an dem Programmieren nah am Blech und wer mehr machen will, für den gibt es Betriebssysteme 2.

17:02.821 --> 17:04.264
Das ist optional.

17:04.304 --> 17:12.818
Und da geht es dann halt zum Beispiel um das Ein- und Ausgrabesystem, um Dateisysteme oder auch um Vortalisierung, wobei wir da so ein paar Vorgriffe haben werden.

17:15.025 --> 17:26.215
Dann gibt es ein Buch, das ist von Avi Silberschatz und vielen anderen inzwischen, das finden Sie in diesem Internet.

17:26.235 --> 17:28.598
Das ist einfach der Klassiker.

17:28.618 --> 17:33.582
Also wenn Sie sich zu Weihnachten ein richtiges Buch wünschen wollen, dann wäre das eine Idee.

17:33.602 --> 17:37.706
Das ist nicht ganz billig, aber hält lange.

17:37.726 --> 17:42.130
Und dann gibt es halt noch diese Vorgeschichte mit dem Windows Internals Course.

17:43.882 --> 17:52.857
Da sind zu nennen der David Solomon, Markus Sinovich, Alex Ionescu und neuerdings Andrea Alivi.

17:54.821 --> 18:06.200
David Solomon ist ein Studienabbrecher, genauso wie Bill Gates, der hat eine Weile studiert und hat mit Dave Cutler bei Dave Cutler Übung gemacht.

18:06.220 --> 18:08.404
Dave Cutler ist der Architekt von

18:08.384 --> 18:16.683
Dem Betriebssystem VMS von der Firma digital gewesen und der Chef Architekt von Windows über eine lange Zeit.

18:16.703 --> 18:22.596
Und David Solomon hat dann angefangen Bücher zu schreiben über Windows intern als Markus Hinowitz ist.

18:24.533 --> 18:39.117
Computer Science Student gewesen, Master und PhD hat er in Carnegie Mellon gemacht und der ist dadurch aufgefallen, wenn sie Windows starten, dann gibt es dann eine Konfigurationsdatenbank, das ist die Registry.

18:39.157 --> 18:43.825
In der Registry steht drin, ob das Ding ein Server oder ein Klient ist.

18:43.805 --> 18:45.627
sind zwei Schlüsseleinträge.

18:45.647 --> 18:48.091
Der eine ist bekannt, der zweite nicht.

18:48.111 --> 18:53.598
Der Unterschied in den Lizenzgebühren sind also mehrere Tausend Dollar.

18:53.658 --> 18:58.104
Und Markus Sinovich hat den Tool programmiert, mit dem man diesen zweiten Schlüssel auslesen konnte.

18:59.086 --> 19:07.517
Das heißt, der war bei Microsoft erst mal auf einer schwarzen Liste für eine ganze Zeit, hat dann eine eigene Firma gegründet, die hieß System Terminals, hat dann dieser Firma

19:07.497 --> 19:15.127
Na ja weitere Werkzeuge programmiert, ich hab ihn dann irgendwann kennengelernt und er hat ein Ziel, dass er nämlich von Microsoft aufgekauft wird.

19:15.187 --> 19:27.103
Das ist zwei Jahre später passiert und inzwischen ist er ein Techniker Fellow und der Architekt sozusagen von Windows Azure, also von dem Cloud, von der Cloud Installation von Microsoft.

19:27.143 --> 19:28.965
Benutzt jemand iCloud hier von Ihnen?

19:30.734 --> 19:32.616
Das ist alles Windows Azure.

19:32.636 --> 19:36.360
Also wenn Sie da denken, Apple ist anders, nee, nee.

19:36.380 --> 19:38.222
Das lohnt sich schon, über Microsoft mal zu reden.

19:38.903 --> 19:42.928
Und Alex Ianesco, haben sich mal von ReactOS gehört.

19:42.948 --> 19:47.032
Das ist ein Versuch, Windows API auf eigene Faust noch mal neu zu programmieren.

19:47.072 --> 19:48.714
Das hat der gemacht.

19:48.794 --> 19:51.277
Und gleiches Schema auf der schwarzen Liste.

19:51.357 --> 19:55.982
Irgendwann dann akzeptiert, inzwischen auch mit Schreiberlink von dem Buch und so weiter.

19:56.215 --> 20:04.133
Und dann kam die anderen haben gesagt, wir wollen es in die akademische Welt tragen und da hat dann Microsoft Akademik Religions gesagt, da braucht den Professor.

20:04.417 --> 20:07.121
Und so kam ich mit den Brüdern in Kontakt.

20:07.181 --> 20:13.309
Das war halt wirklich 2002, vier bis sechs, so in diesem Zeitfenster.

20:13.329 --> 20:19.298
Und dann gab es eine Geschichte, Curriculum Resource Kit hieß es und Faculty Connection.

20:19.318 --> 20:24.665
Dort war oder dieser groß viel lange Zeit gelistet und als Top-Download.

20:24.685 --> 20:28.230
Inzwischen hat Microsoft das Interesse an Windows verloren.

20:28.210 --> 20:33.576
Ja, weil wir machen alle cloud und wir machen alle embedded und.

20:33.596 --> 20:37.860
Ja, jetzt gibt's dieses Microsoft Windows Academic Program nicht mehr.

20:37.900 --> 20:44.607
Wir haben hier diese DVDs aus der Zeit natürlich noch und was.

20:44.627 --> 20:48.451
Damals cool war und das kann man heute immer noch machen, aber es ist ein bisschen umständlich.

20:48.471 --> 20:52.416
Also wenn Sie Lust haben, gehen Sie auf die Reise.

20:52.436 --> 20:54.758
Es gab die sogenannte.

20:55.312 --> 21:01.573
Den Windows Research Corner, der Windows Research Corner ist ein quäl offener Kern.

21:01.613 --> 21:07.212
Ein paar Gerätetreiber sind nur näher verfügbar, zum Beispiel das Fallsystem, aber alle Quellen von Windows.

21:08.609 --> 21:14.997
kein Userland, kein cmd.exe, kein Explorer, aber alle Quellen des Kernels.

21:15.037 --> 21:22.988
Und Sie können diesen Kernel installieren in dem Windows 2003 Server als zweiten Bootkörner.

21:23.048 --> 21:25.391
Und dann haben Sie ein vollständiges System.

21:25.431 --> 21:34.262
Wenn Sie heute in 2003 Server irgendwo installieren, dann dauert es keine 30 Minuten, dann ist das Ding so was von Viren verseucht, dass es praktisch nicht mehr funktioniert.

21:34.242 --> 21:38.089
In einem geschützten Umgebung im isolierten Netz kann man das Ganze spielen.

21:38.130 --> 21:40.674
Wir haben auch noch virtuelle Maschinen, wo es drin geht.

21:41.736 --> 21:47.728
Und jetzt kann man sich los hinstellen und sagen, wir wollen mal ein Systemaufruf programmieren in Windows.

21:48.350 --> 21:51.095
oder wir wollen mal einen kleinen Trojaner programmieren.

21:51.796 --> 22:02.875
Wir werden uns beim Scheduling darüber unterhalten, dass Betriebssystem heutzutage strats schedule und nicht Prozesse, was das sind, kommt noch.

22:02.896 --> 22:09.447
Wenn Sie sich Tools angucken wie den Explorer oder Task Manager, dann sehen Sie dort Prozesse.

22:09.427 --> 22:18.775
Und diese Prozesse, die kann man in der Prozessliste, das ist eine doppelt verkehrtete Liste, Sie erinnern sich an PD2, da können Sie einfach den einfach rauslöschen.

22:18.816 --> 22:23.199
Dann laufen die Scouts weiter, das Programm läuft weiter wie gehabt.

22:23.220 --> 22:26.863
Es gibt einen kleinen Haken, nicht das war eine von den Übungsaufgaben.

22:26.883 --> 22:31.207
Wir lassen mal einen Prozess verschwinden und dann läuft das Programm trotzdem weiter.

22:31.227 --> 22:33.609
Fertig ist der Trojaner.

22:33.629 --> 22:39.214
Das Problem ist, dass Sie an dieser Liste manipulieren, Sie nehmen dort gerade ein Element raus.

22:40.055 --> 22:44.642
und das Betriebssystem greift im gleichen Moment auf die Liste zu.

22:44.662 --> 22:46.725
Jetzt werden Sie sagen, wie kann es passieren?

22:46.785 --> 22:51.912
Ich habe ja nur einen Prozessor, nein, Sie haben ja einen Multicore, Sie haben ja viele Prozessor in Ihrem Computer.

22:51.932 --> 23:00.144
Und jetzt kommt der Unterschied zwischen nebenläufig und gleichzeitig parallel und nebenläufig zum Tragen, manche Aktivitäten passieren parallel.

23:00.224 --> 23:00.865
Und wenn man

23:02.245 --> 23:14.441
jetzt nicht weiß, mit welcher Synchronisationsvariable diese Liste geschützt wird, dann kann es halt passieren, dass beide sich in die Haare kriegen, das Betriebssystem und ihr Code, dann wird es einfach das System stehen bleiben.

23:14.481 --> 23:15.863
Was passiert dann?

23:15.903 --> 23:17.565
Da gibt es einen sogenannten Blue Screen.

23:17.585 --> 23:21.450
Haben Sie schon mal einen Blue Screen gesehen?

23:21.510 --> 23:24.174
Ist es gut oder schlecht?

23:24.214 --> 23:26.217
Das ist toll.

23:26.237 --> 23:31.864
Stellt sich vor, Sie haben einen Computer mit, sagen wir mal, 256 Prozessoren.

23:32.502 --> 23:35.467
Wir haben solche Server in unserem Deler Center.

23:35.507 --> 23:40.755
Wir haben dort Maschinen mit acht Terabyte Hauptspeicher, also richtig größere Knochen.

23:40.775 --> 23:52.012
Und stellen sich vor, wie viel Schaden die restlichen 255 Prozessoren anrichten können, während ihr einer Prozessor gerade festgestellt hat, dass durch eine Datenstruktur kaputt ist.

23:52.033 --> 23:55.318
Das heißt, sie wollen die anderen Prozessoren so schnell wie möglich stoppen.

23:55.358 --> 23:58.122
Sie wollen das System geordnet runterfahren.

23:58.102 --> 24:02.728
Und jetzt haben Sie schon Programme geschrieben, nicht?

24:02.788 --> 24:05.592
In pd1.

24:05.632 --> 24:08.255
In welcher Sprache haben Sie denn da geschrieben?

24:08.275 --> 24:11.620
Hat jemand in C-Programme geschrieben?

24:11.660 --> 24:13.122
In Java?

24:13.142 --> 24:15.285
In pd2 vielleicht?

24:15.325 --> 24:18.789
In Python?

24:18.809 --> 24:23.295
Haben Sie in C schon mal ein Programm geschrieben, was mehr als eine Aktivität gleichzeitig ausführt?

24:23.315 --> 24:24.717
Meeres Rats zum Beispiel?

24:26.452 --> 24:32.148
Dann haben Sie sozusagen den Teil, um den sich hier sehr viel dreht, noch gar nicht erlebt.

24:32.850 --> 24:37.201
Das Problem ist nämlich, wenn zwei gleichzeitig auf eine Datastruktur zugreifen wollen.

24:37.222 --> 24:38.826
Wie synchronisiert man die beiden?

24:38.866 --> 24:41.794
Wie sorgt man dafür, dass da eine wartet, bis der andere fertig ist?

24:42.736 --> 24:45.459
Und dieses Thema, das muss man an der Stelle lösen.

24:45.479 --> 24:48.223
Das ist die Stelle, wo der Blueskrieg eine Rolle spielt.

24:48.243 --> 24:51.206
Geordnet runterfahren von Systemen in Fehlerfällen.

24:51.246 --> 24:52.448
Spannendes Ding.

24:52.468 --> 24:56.112
Wir werden sehen, dass es bis in die Speicherverwaltung ganz tief reingreift.

24:56.132 --> 24:59.937
Weil allein die Frage nicht, gehen Sie mal davon aus, Ihr Speicher ist komplett korrumpiert.

24:59.957 --> 25:04.743
Wie schaffen Sie das auf dem Bild schon noch was anzuzeigen?

25:04.783 --> 25:06.465
Ohne, dass da ein Corderwelt steht.

25:07.289 --> 25:10.135
Ja, das macht das Betriebssystem beim Start als allererstes.

25:10.155 --> 25:14.524
Das legt ein Stück Speicher zur Seite und sagt nur für den Blue Screen.

25:14.544 --> 25:22.019
Also, wenn das irgendwann mal soweit kommt, dass wir eine Panik haben und das System anhalten müssen, Linux sagt dazu übrigens Panik und Linux auch.

25:22.039 --> 25:28.352
Also, diese Aufgabe lösen alle Betriebssysteme, aber anhand von dem, wenn wir es researchen können, kann man sich sowas halt angucken.

25:30.222 --> 25:32.906
Achso, dann haben wir über eine lange Zeit dazu auch ein Blog gemacht.

25:32.926 --> 25:33.947
Da gab es zwei Doktoranden.

25:33.967 --> 25:38.533
Der eine ist Alexander Schmidt, der ist inzwischen bei Microsoft und macht Windows Server Update.

25:38.553 --> 25:46.704
Der andere heißt Michael Schübel, der ist in Berlin Schöneberg und arbeitet in so einer Embedded Firma.

25:46.724 --> 25:49.227
Die haben diesen Blog eine ganze Weile betrieben.

25:50.033 --> 26:01.648
Genau, so viel vielleicht zur Vorgeschichte und dann verstehen Sie jetzt oder nehmen Sie jedenfalls zur Kenntnis, dass wir in diesem Kurs uns mit Winners als Beispiel beschäftigen.

26:01.708 --> 26:09.538
Das heißt aber nicht, dass Sie alles über Winners wissen müssen und sonst nichts, sondern das heißt lediglich, das ist ein Beispiel wie jedes andere.

26:09.738 --> 26:13.123
Und Winners als Beispiel ist aus verschiedenen Gründen interessant.

26:13.163 --> 26:19.551
Ich blätter hier vielleicht mal ganz kurz in meinem Dateis-Thema herum.

26:23.092 --> 26:35.489
Gleich gehen wir hier mal hin.

26:35.509 --> 26:38.353
Mit ein bisschen Glück geht das Wort auch an.

26:38.373 --> 26:42.458
Und dann sehen Sie mal einen Entwurfsdokument.

26:42.498 --> 26:44.461
Das ist heute im Museum.

26:44.481 --> 26:47.445
Die Hardcopy von diesem Dokument steht im

26:47.746 --> 26:54.216
Smithsonian Museum of in Washington.

26:54.236 --> 27:03.330
Dass es diese Dokumente gibt, die wurden geschrieben in Wörth, in Wörth Version 2 und Wörth ist auch immer aufwärtskompatibel zur nächsten Version.

27:03.370 --> 27:15.829
Das heißt, es gab einen Kollegen, Dave Robert heißt der bei Microsoft, der hat das von Version 2 nach Version 3 konvertiert und dann nach Version 4 und so weiter und hat dann schließlich da draußen gültige Wörth Dokument gemacht.

27:15.809 --> 27:25.982
Was aber das originale Designdokument oder die Designdokumente von Windows sind, aus 1989.

27:26.002 --> 27:32.049
Und damals redete man noch nicht von Windows, sondern man redete von NTOS 2.

27:32.069 --> 27:34.272
Haben Sie sich mal von OS 2 gehört?

27:34.292 --> 27:37.876
Das war ein Betriebssystem, was die IBM bei Microsoft einen Auftrag gegeben hat.

27:37.897 --> 27:40.720
Und das wollte man in der neuen Fassung bauen.

27:40.700 --> 27:50.190
Und manche sagen NT steht für New Technology, manche sagen NT steht für Entend, den Kotnamen des Prozessors, den man damals hatte, in Intel 860.

27:50.210 --> 27:51.411
Wie auch immer.

27:51.471 --> 27:55.416
In diesem Dokument steht drin, wie Windows funktionieren soll.

27:55.436 --> 28:07.489
Und es sollte also portabel sein, es sollte verschiedene Prozessoren unterstützen, es sollte kompatibel sein mit dem OS 2, es sollte Sicherheit unterstützen, es sollte POSIX unterstützen.

28:07.529 --> 28:08.850
Was war POSIX gleich noch?

28:09.995 --> 28:13.103
POSIX ist UNIX, gibt es einen Spruch.

28:13.143 --> 28:16.912
POSIX ist eine Betriebssystemschnittstelle.

28:16.933 --> 28:19.399
Viele UNIX erfüllen es, viele andere Systeme auch.

28:19.439 --> 28:26.637
Es gab damals in den 1990er Jahren eine Direktive von der amerikanischen Regierung, die gesagt hat, wir kaufen nur noch POSIX-kompatible Systeme.

28:27.595 --> 28:34.484
Das heißt, damit die Leute Windows kaufen konnten in der Regierung, in der Administration, musste das Ding auf einmal POSIX kompatibel sein.

28:35.466 --> 28:38.550
Das heißt, Windows hat mehrere Persönlichkeiten.

28:38.570 --> 28:46.400
Es hat die OS2-Persönlichkeit, es hat eine POSIX-Persönlichkeit und es hat auch eine Windows-Persönlichkeit.

28:46.420 --> 28:51.527
Im Netzwerk wollte man auch einbauen und dann hat man auch gesagt, wir wollen es bauen so.

28:51.507 --> 28:55.995
Also hier ist meine schöne ASCII-Grafik.

28:56.035 --> 29:00.263
Kann versuchen, das noch ein bisschen größer zu machen, mal sehen.

29:00.323 --> 29:09.300
Und dann sehen wir hier unten, gibt es Gerätetreiber und dann gibt es einen Executive und dann gibt es ein File-System und ein Object Manager, Memory Management in der Prozesskondition.

29:09.320 --> 29:13.347
Also alles das, was im Kernel passiert und das heißt hier Entors Executive.

29:14.170 --> 29:16.654
Wo kommt das Executive her?

29:16.674 --> 29:18.577
Auch wieder eine historische Geschichte.

29:18.617 --> 29:22.864
Zu der Zeit wirklich an der vorne Front in Sachen Speicherverwaltung war die Wax.

29:22.904 --> 29:26.870
Die Wax war ein Computer von der Firma Digital und die hatte vier Protection Modi.

29:26.890 --> 29:29.154
Sie haben vielleicht schon mal von Kernel und User gehört.

29:29.194 --> 29:30.656
Das Ding hatte vier.

29:30.676 --> 29:34.542
Das hatte nämlich Kernel, Executive, Supervisor und User.

29:34.522 --> 29:41.590
Und entsprechend hat man das Betriebssystem so strukturiert, wie das alte VMS-Betriebssystem mit vier verschiedenen Protection-Modi.

29:41.630 --> 29:45.635
Und hat dann aber festgestellt, dass man ja portabel sein wollte.

29:45.655 --> 29:50.440
Und die Risk-Prozessoren, die damals auf den Markt kamen, die hatten nur noch zwei Protection-Modi.

29:50.480 --> 29:53.924
Also hat man das alles zusammengefasst und das heißt manchmal Executive.

29:53.944 --> 29:56.607
Das ist der Teil, der nach oben exponiert wird.

29:56.627 --> 29:59.150
Und der Rest heißt hier unten Körnerl oder Gerätetreiber.

29:59.190 --> 30:00.352
Das ist heute der Körnerl.

30:00.372 --> 30:02.474
Und das ist in Windows noch genauso.

30:02.494 --> 30:04.056
Wir werden das Bild wiedererkennen.

30:04.762 --> 30:11.062
Und der Punkt, warum ich denke, dass es besonders interessant ist, sich über Windows zu unterhalten, der ist eigentlich hier oben zu sehen.

30:11.082 --> 30:13.489
Sie sehen mich hier, von Windows ist gar nicht die Rede.

30:14.667 --> 30:16.790
Dann hier ist von OS 2 die Reden von POSIX.

30:16.810 --> 30:25.142
Windows kam damals als Windows 3.1 oder Windows 3.11, Windows für Work Groups auf der 16-Bit-Plattform und wurde populär.

30:25.162 --> 30:30.870
Man hat damals kurzerhand diese grafischen Ohrflächen von Mac nachgebaut und für die Massen tauglich gemacht.

30:32.032 --> 30:33.314
Von Windows war noch nicht die Rede.

30:33.334 --> 30:35.697
Das kam als drittes Subsystem erst später dazu.

30:36.706 --> 30:43.734
Und ist heute das einzige dominante Subsystem, die anderen des POSIX gibt es noch so ein bisschen, wo es lange verschwunden in der Versenkung.

30:43.774 --> 30:48.359
Aber typisch und das bleibt so ist, wir haben Prozesse.

30:48.400 --> 30:50.182
Prozesse sind Programme in Ausführung.

30:50.202 --> 30:57.650
Also wir haben Programme, die laufen, die stürzen sich ab einmal auf dem POSIX-Subsystem oder auf dem OS2-Subsystem, manche sagen OS halbe.

30:57.750 --> 31:02.336
Und darunter gibt es dann noch weitere Services, die auch im User-Mod laufen.

31:02.356 --> 31:03.557
Und die gibt es heute nach wie vor.

31:04.617 --> 31:18.756
Also, man hat 1989 eine Architektur auf den Tisch gelegt, die damals relativ revolutionär und cool war, inspiriert nebenbei von dem Mach-Betriebssystem, was bei Carnegie Mellon entstand, und hat dann gesagt, so bauen wir jetzt Betriebssysteme.

31:18.797 --> 31:22.482
Und diese Architekturdiskussion, ja, die ist Bestandteil von der Vorlesung.

31:22.502 --> 31:34.438
Also, ich möchte gerne, dass wir hier ein bisschen mehr reden, als nur, wie fühlten sich Windows heute an, aber dass Sie auch verstehen, Windows fühlt sich heute so an, weil man damals Architekturentscheidungen getroffen hat, die halt sozusagen

31:36.140 --> 31:39.162
allgemeingültig sind.

31:39.182 --> 31:40.632
Was ist jetzt ein Betriebssystem?

31:41.185 --> 31:48.695
Es geht um Ressourcenverwaltung, um eine Schnittstelle zwischen Hardware und Software.

31:49.516 --> 32:00.732
Jetzt könnte man sagen, ein Betriebssystem ist das, was auf der Hersteller DVD kommt oder auf der CD oder in dem Tarball oder wie immer die Paketmännische heißen, die Sie gerade verwenden.

32:00.752 --> 32:03.395
Betriebssysteme gibt es überall.

32:03.415 --> 32:08.442
In ganz kleinen Computern, in großen Computern,

32:09.687 --> 32:13.872
in Systemen, die gar keine Benutzer-Uberfläche haben.

32:13.932 --> 32:19.318
Und Ressortsmanagement, Programmsteuerung, das waren die ersten Aufgaben.

32:20.419 --> 32:26.606
Also im Betriebssystem ist die Schnittstelle zwischen Computer-Hardware und dem Computernutzer.

32:26.666 --> 32:37.939
Und hilft dem Programmierersachen besser zu erledigen, macht den Computer einfacher, benutzbar und gibt dem Kind einen Namen.

32:38.543 --> 32:45.997
Wenn Sie Unix angucken, da gibt es den Satz, jede Ressource des Computers wird durch ein Dateinamen dargestellt oder als Datei.

32:46.037 --> 32:50.906
In Windows, das ist ein objektbasiertes System, da wird jede Ressource durch Objekte dargestellt.

32:53.431 --> 32:58.881
Ressourcenallocator oder alles das, was man kauft, was auf der DVD kommt.

33:02.590 --> 33:10.491
Man könnte auch sagen, das ist das eine Programm, das immer zu auf dem Computer unterwegs ist, was immer läuft, wenn sonst nichts los ist.

33:10.511 --> 33:18.152
Und das ist der Kernel und dann gibt es eine Reihe von Systemprogrammen, die im User-Mod laufen, aber nicht Teil von Kernel sind.

33:18.132 --> 33:20.755
Und dann gibt es Anwendungsprogramme.

33:20.775 --> 33:23.578
Und dann gibt es noch so ein Wort, das heißt Mittelwehr.

33:23.598 --> 33:29.164
Sie haben vielleicht schon mal im Duden nachgeguckt und wissen, dass Hardware ein deutsches Wort ist und Software auch.

33:29.184 --> 33:31.066
Mittelwehr noch nicht.

33:31.086 --> 33:38.054
Mittelwehr ist quasi die Schicht Software, die das noch nicht ins Betriebssystem geschafft hat.

33:38.074 --> 33:42.739
Wo man sagt, das ist schon so ein bisschen Standard, irgendwelche Web-APIs oder irgendwelche

33:42.719 --> 33:55.182
Verteilten Systeme Software sowie Korba oder KOM noch nicht bestand von Betriebssystem, aber doch für eine Vereinheitlichung gut zu gebrauchen.

33:55.202 --> 33:59.850
Wenn Sie heute Computer benutzen, dann teilen Sie Daten über

34:00.455 --> 34:04.281
OneDrive oder NextCloud oder so ein Krämpel.

34:04.301 --> 34:13.356
Vielleicht benutzen Sie auch ein Netzwerk-Feilsystem, NFS oder AFP oder SMB als Feilsharing-Protokolle.

34:13.376 --> 34:18.364
Die sind heute Bestandteil von Betriebssystemen.

34:18.384 --> 34:21.889
Das war in den 1980er, 90er Jahren nicht so.

34:21.910 --> 34:25.956
Da kam die als Aufsatz, als Mittelwehr und Hansen zwischen ins Betriebssystem geschafft.

34:28.535 --> 34:30.377
Was machen Betriebssysteme?

34:30.417 --> 34:36.824
Naja, für den Benutzer steht die Einfachheit der Benutzung und die Performance im Mittelpunkt.

34:36.844 --> 34:41.369
Dann gibt es andere Computer, Mainframe als Beispiel genannt hier.

34:41.389 --> 34:44.592
Da müssen viele Nutzer zufrieden gestellt werden.

34:44.632 --> 34:48.416
Haben Sie schon mal den Begriff Mainframe vernommen?

34:48.436 --> 34:52.080
Haben Sie so ein Ding schon mal gesehen, googeln Sie mal.

34:52.100 --> 34:52.821
Das sind

34:53.577 --> 35:02.805
Diese ganze Diskussion, die sie in der Grundlagen digitaler Systeme hatten, der ganze Begriff Computer Architecture, der kommt von den Mainframes her.

35:02.826 --> 35:08.831
Die wurden 1964 von der Firma IBM mit dem System 360 auf den Markt gebracht.

35:08.891 --> 35:15.898
Und seitdem haben die es geschafft, eine Aufwärtskompatibilität zu erreichen.

35:15.958 --> 35:21.863
Das heißt, die können im Programm von 1964 auf einem Computer von 2025 immer noch laufen lassen.

35:22.231 --> 35:24.616
Das ist ein Markenzeichen der Mainframes.

35:24.636 --> 35:28.465
Tatsächlich sind das die Systeme, die die Welt bewegen.

35:28.485 --> 35:31.872
Es gibt ungefähr 5.000 Stück auf der Welt.

35:31.892 --> 35:33.075
Die Zahl bleibt gleich.

35:33.095 --> 35:34.177
Sie können die Dinger nicht kaufen.

35:34.217 --> 35:35.641
Sie können sie nur lizenzieren.

35:35.681 --> 35:39.008
Ein Prozessor lizenzieren sie ungefähr ab 100.000 Dollar.

35:38.988 --> 35:43.198
Na oben ist die Grenze offen.

35:43.218 --> 35:44.641
Wer hat so viel Geld?

35:44.701 --> 35:46.666
Na ja, die Banken natürlich.

35:46.726 --> 35:52.540
Das heißt, ungefähr die Hälfte bis zu 70 Prozent der E-Commerce-Transaktionen gehen über diese Mainframe.

35:52.660 --> 35:54.785
Wenn Sie eine Flugbuchung machen, ist eine Mainframe dabei.

35:54.805 --> 35:57.351
Wenn Sie ein Ticket kaufen bei der Bahn, ist eine Mainframe dabei.

35:57.331 --> 36:00.575
Und so weiter.

36:00.595 --> 36:04.520
Die Dinger werden heute vermarktet von der IBM als Z-Series.

36:04.540 --> 36:07.324
Das Z steht für Zero-Down-Time.

36:07.364 --> 36:09.486
Das heißt, die gehen niemals aus.

36:09.667 --> 36:12.971
Jetzt können Sie mal kurz überlegen, warum Ihr Computer zu Hause ausgeht.

36:14.032 --> 36:14.853
Weil der Strom alle ist.

36:14.893 --> 36:19.319
Okay, da sind diese Aggregaten und Batterien, dann geht der Strom nicht mehr aus.

36:19.339 --> 36:20.200
Einfach.

36:20.618 --> 36:23.062
Aber wie ist es denn mit Software-Updates?

36:23.082 --> 36:26.827
Wie ist es mit Antivieren und Wartung und so weiter?

36:26.847 --> 36:32.696
Manchmal haben sie vielleicht auch einen Kernotrap und die System bleibt stehen und startet neu.

36:32.716 --> 36:36.922
Das heißt, die Mainframe sind Design, so dass die Rolling-Updates machen.

36:36.963 --> 36:39.887
Also die können während des Betriebs Updates rein spielen.

36:39.907 --> 36:43.032
Dafür wird die Maschine nie ausgeschaltet.

36:43.052 --> 36:45.656
Wenn die Dinger sich verrechnen, passiert Folgendes.

36:45.676 --> 36:48.600
Heutzutage macht man das mit Coding-Theorie, aber für

36:48.580 --> 36:52.804
Lange Zeit war es so, dass jede Instruktion einfach zweimal gerechnet wird.

36:52.824 --> 36:54.266
Ergebnisse werden verglichen.

36:54.306 --> 36:56.528
Wenn die nicht übereinstimmen, versucht man es noch mal.

36:56.548 --> 37:00.012
Wenn die Ergebnisse wieder nicht übereinstimmen, nehmen wir einen anderen Prozessor.

37:00.032 --> 37:06.599
Wenn die Ergebnisse dann nicht übereinstimmen, dann sagen wir an den Betriebssystem Bescheid und es geht auf die Nachbarmaschine.

37:06.619 --> 37:10.803
Also das sind Maschinen, die unter allen Umständen durchhalten.

37:10.924 --> 37:15.128
Speicher, haben Sie schon mal von ECC RAM gehört?

37:15.378 --> 37:18.644
Also Fehler korrigierenden Speicher.

37:18.664 --> 37:30.224
Das ist nicht nur so, dass die Maschinen Verschlüsselungstheorie oder Codingstheorie benutzen, um die Daten im Speicher sicher zu halten und Leseschreibfehler zu erkennen, sondern die Speichern redundant.

37:30.244 --> 37:34.011
Da gibt es also Reim, Redundant, Array auf independent memory.

37:34.328 --> 37:39.176
Das heißt, anstelle die Daten einmal zu speichern, speichern wir sie zweimal.

37:39.196 --> 37:43.463
Im EU-Fahrt haben wir Redundanz im Storage-System sowieso.

37:43.483 --> 37:49.072
Also alles doppelt und dreifach abgesichert, damit diese Kisten niemals ausfallen.

37:49.112 --> 37:53.439
Wie gesagt, wenn Sie zum Geldautomaten gehen, am Ende steht eine Mainframe.

37:53.459 --> 37:59.408
Wir haben mehrere Male, auch das können Sie sich angucken.

37:59.388 --> 38:05.820
Bei OpenHPI mit der IBM Block-Krosse gemacht zum Thema Mainframe Computing.

38:16.212 --> 38:18.296
Genau.

38:18.316 --> 38:23.366
Und das Ende der Fahnenstange sind dann immer irgendwie Vorträge aus der Industrie.

38:23.386 --> 38:25.590
Haben Sie einen Sparkassenkonto?

38:25.610 --> 38:27.654
Gibt es Menschen, die einen Sparkassenkonto haben?

38:27.674 --> 38:30.559
Stellen Sie sich vor, Sparkasse IT funktioniert folgendermaßen.

38:30.599 --> 38:32.483
Wir teilen Deutschland auf nach Süd und Nord.

38:32.463 --> 38:36.688
Dann teilen wir es noch mal auf in zwei Hälften aus Redundanzgründen.

38:36.708 --> 38:39.771
Es gibt nämlich bei der Meenfräben Konzept, das heißt parallel Sysplex.

38:39.811 --> 38:43.716
Man kann Maschinen im Verbund betreiben bis zu 11 Kilometer Distanz.

38:43.756 --> 38:46.679
Das heißt das große Rechenzentrum der Sparkasse im Norden.

38:46.719 --> 38:49.042
Das ist in einer Münster-Rahner Ecke.

38:49.062 --> 38:50.824
Da gibt es zwei Rechenzentren.

38:50.844 --> 39:00.175
Da stehen im Frontend 15 Power Systeme, die sozusagen das ganze Web machen und im Backend 15 Meenfräben.

39:00.155 --> 39:05.564
Das storage-System ist von Hitachi und nicht von IBM, weil nicht alles von IBM gekauft werden sollte.

39:05.584 --> 39:07.608
Aber das ist die Sparkasse.

39:07.628 --> 39:15.561
400.000 Arbeitsplätze und Kontorausdrucker und Geldautomaten an 15 Servern.

39:15.601 --> 39:21.070
Das sind also Maschinen, die werden Sie nicht so häufig im Leben sehen.

39:21.090 --> 39:26.179
Und da sind die Betriebssysteme dann auch so ein bisschen anders, als man das hier diskutiert.

39:27.982 --> 39:34.710
Wir reden über Wachstations, wir reden über Maschinen, die im Prinzip von einer Person benutzt werden.

39:34.730 --> 39:40.217
Die müssen Ressourceverwaltung anders machen als bei solchen geschärten, gemeinsamen Benutzungsservern.

39:40.257 --> 39:42.760
Bei mobilen System ist es noch mal ganz anders.

39:42.800 --> 39:48.647
Und dann gibt es noch Maschinen ohne User interface, die müssen halt einfach funktionieren.

39:48.667 --> 39:53.112
Lustigerweise, es gab auch von Windows, manne Variante, oder gibt es immer noch Windows Embedded.

39:53.682 --> 40:01.233
Die größte Änderung dort, wenn immer so eine Dialogbox kommt, ja oder nein, dann sagt er automatisch ja.

40:01.253 --> 40:08.564
Und damit hat man schon geschafft, das Windows ohne Display zu betreiben.

40:08.625 --> 40:12.871
OS 360, das war dieses Betriebssystem von Armeenfrem.

40:12.891 --> 40:19.521
Haben Sie schon mal von dem Buch gehört, der mystische Mannmonat oder es gibt keine Silber?

40:20.311 --> 40:35.232
Das ist ein Buch von dem Radio Boots, dem Projekt Manager von dem US 360 System, weil als dieses System 1964 gebaut wurde, war es ein Riesendesaster.

40:35.920 --> 40:48.901
Es kam zu spät auf dem Markt, das war zu groß, das passte nicht auf den Computer des Betriebssystems und man ist nur dadurch durch die Tür gekommen, dass man noch eine zweite Beirante gebaut hat von den Betriebssystems, die ist DOS 360.

40:48.941 --> 40:56.713
Das gibt es heute immer noch als VSE, hat nebenbei nicht den Pinguin als Zeichen, sondern die Katze für die sieben Leben, wird immer noch in Böblingen gepflegt.

40:57.031 --> 41:00.897
Und damit konnte man überhaupt erst mal die Systeme verkaufen.

41:00.918 --> 41:08.190
Und später dann hat man die Software in den Griff gekriegt und dieses OS 360 kam in den Markt.

41:08.230 --> 41:09.532
Und dann gab es einen zweiten Punkt.

41:09.552 --> 41:17.145
Für das OS 360 hat man eine eigene Programmiersprache gebaut, PL1, Programming Language One, klar.

41:17.185 --> 41:23.275
Und dann mit einer Spezialität PLS, ja, für System Programming.

41:23.879 --> 41:30.632
Man hatte dann den Anfang der 70er Jahre das Phänomen, dass man Fehler gefunden hat in der Software, logisch.

41:30.652 --> 41:35.460
Aber beim Reparieren eines Fehler hat man mehr neue Fehler ins System eingefügt, als man repariert hat.

41:36.402 --> 41:41.311
Das führte also zu einem Terminus, der damals als Softwarekrise bezeichnet wurde.

41:41.371 --> 41:47.102
Es war klar, dass die Komplexität von Systemen nicht weiter steigen kann mit den damals üblichen Softwarewerkzeugen.

41:47.555 --> 41:48.617
Wie hat man programmiert?

41:48.637 --> 41:52.463
Man hat ein Semblersprache programmiert und man hatte vielleicht rudimentäre Compiler.

41:52.984 --> 42:06.728
Das hat aber dazu geführt, dass man in Informatik eine ganze eigene Branche aufgemacht hat, nämlich die Softwaretechnik als Disziplin, dass man also Werkzeuge entwickelt hat, die die Kotqualität verbessern und wenn sie wollen,

42:07.012 --> 42:12.738
ist die ganze Geschichte vom HPI eine Geschichte, die mit dem OS 360 angefangen hat.

42:12.778 --> 42:17.404
Ohne dieses Disaster damals, keine Softwaretechnik.

42:17.424 --> 42:19.967
Das Ganze hat sich nebenbei bei der SAP wiederholt.

42:19.987 --> 42:36.445
Und das ist der wirkliche Grund, warum Hasu Platna damals Siegfried Wendt, den Betreuer seiner Diplomarbeit in Karlsruhe, reaktiviert hat und Siegfried Wendt als Gründungsdirektor des Instituts 1998, 1999 angefangen hat hier.

42:36.880 --> 42:39.263
Software Technik zu lernen.

42:39.284 --> 42:43.430
Inzwischen erleben Sie das HPI viel diverser und breiter aufgestellt.

42:43.470 --> 42:45.773
Neue Themen sind dazugekommen.

42:45.813 --> 42:53.644
Aber haben Sie das ruhig im Kopf ohne Betriebssysteme können HPI?

42:53.685 --> 42:53.925
Naja.

42:55.988 --> 42:59.513
Andere Betriebssysteme UNIX, Windows, haben wir darüber geredet, Null Linux.

43:03.087 --> 43:05.211
Über Free Software reden wir später nochmal.

43:05.251 --> 43:09.198
Haben Sie schon mal von der Free Software Foundation FSF gehört?

43:09.258 --> 43:12.304
Richard Stormen, den hatten wir irgendwann mal hier.

43:12.344 --> 43:22.783
Das ist jemand, der sich weigert, kommerzielle, proprietäre Software zu verwenden, der deshalb also zum Beispiel auch nicht online in Flugzeuge einschicken kann.

43:24.232 --> 43:36.030
weil da läuft proprietärer ja was kippcode und deshalb braucht er immer jemanden der eben papier ticket druckt also so ganz konsequent zu leben ist schwer.

43:36.466 --> 43:53.830
Aber Richard Stormen hat lange Zeit gearbeitet am MIT an Open Source Software unter einem X-Windows-System, Projekt Athena, ganz frühe Fenster-Systeme für X.

43:53.910 --> 43:58.997
Und gefördert wurde das ganze damals durch die Firma Deck in Massachusetts.

43:58.977 --> 44:06.167
Die Open Software oder Free Software Foundation hat eine lange Tradition und auch eine Förderung durch die Industrie.

44:06.187 --> 44:07.348
Und heute ist es nicht anders.

44:07.368 --> 44:18.703
Also diese ganze Free Software ist der einzige Weg, Software heute lange im Markt zu halten und überlebensfähig zu machen.

44:18.723 --> 44:20.125
Und nur Linux steht dafür halt.

44:21.792 --> 44:41.252
Mac OS, ein Betriebssystem, was hier gerade läuft, was aber in Wirklichkeit auf Macht beruht und auf dem Berkeley System Distribution von UNIX, den Androiden, das ist ein bisschen Linux, iOS ist ein bisschen Mac OS, das sind Betriebssysteme, die sie heute im Telefon haben, die machen an manchen Stellen Sachen anders.

44:41.232 --> 44:49.447
Also beispielsweise, wenn Sie bei Apple schon mal irgendwie sich gefreut haben, wie schnell dieses Telefon reagiert, Sie starten eine App und die ist schon da.

44:49.467 --> 44:50.389
Nee, gar nicht.

44:50.409 --> 44:55.098
Der macht einen Schnappschuss von dem letzten Zustand und zeigt Ihnen erst mal das Bild.

44:55.118 --> 44:59.967
Ja, und dann kann einem im Hintergrund die Applikation langsam starten und dann geht es richtig los.

44:59.947 --> 45:11.663
Der Android, der hat so ein Out-of-Memory-Killer, also wenn da irgendwie der Speicher knapp wird, wir haben ja keine Festplatte, wo wir Sachen hinauslagern können, dann killen wir Prozesse einfach und räumen die raus.

45:11.704 --> 45:15.389
Das heißt, bei diesen Betriebssystemen gelten andere Annahmen.

45:15.429 --> 45:19.795
Ein Prozess muss gewahr sein, dass er zu jedem Zeitpunkt terminiert werden kann.

45:20.195 --> 45:27.726
Das heißt, der muss seinen Zustand immer irgendwo im Speicher, also Checkpoints schreiben sozusagen.

45:30.102 --> 45:40.479
Wie gesagt, viele Betriebssysteme erscheinen heute als geschlossene Close-Source-Systeme.

45:40.499 --> 45:41.941
MacOS.

45:41.961 --> 45:45.286
Haben Sie schon mal bei opensource.apple.com hingeglickt?

45:45.307 --> 45:50.575
Dort finden Sie die Quellen von MacOS, die vom iOS interessanterweise nicht.

45:50.791 --> 45:55.439
Bei Windows hatte ich Ihnen vom Windows Research Colonel erzählt.

45:55.459 --> 46:01.949
Traditionell war es üblich, dass man Betriebssysteme mit den Quellen gekauft hat.

46:01.969 --> 46:05.856
Diese Quellen waren dann lesbar, zum Beispiel, auf Mikrofisches.

46:05.916 --> 46:07.839
Also nicht unbedingt auf einem Band.

46:07.859 --> 46:11.665
Aber wenn Sie Pratu verstehen wollen, was hier los ist, konnte man sich es angucken.

46:11.705 --> 46:15.752
Und das ist eine Sache, die wird jetzt hier sozusagen fortgesetzt.

46:20.103 --> 46:25.492
Wie gesagt, die Folien, die sind didaktisch viel besser als die in den Jahren davor.

46:25.532 --> 46:33.226
Hier haben sie einen Vorgriff auf das Betriebssystem mit zwei, vielleicht auch so ein bisschen mundwässrig machen.

46:33.246 --> 46:37.513
Dass man mit so vielen Betriebssystemen heute rumspielen kann, liegt daran, dass wir virtuelle Maschinen haben.

46:37.553 --> 46:42.702
Das wir also Container bauen können, in denen wir ein altes Betriebssystem auf aktueller Hardware betreiben können.

46:42.682 --> 46:49.255
Wie diese Virtualisierung genau funktioniert, das besprechen wir in Betriebssysteme 2.

46:49.295 --> 46:53.764
Heute nehmen wir einfach mal an, das geht und Sie gucken sich das an.

46:53.804 --> 47:00.117
VirtualBox ist eine Art virtuelle Maschinen auszuführen, wir werden da reden über

47:00.097 --> 47:09.731
Hosted Virtualisierung und Ful Virtualization und Paravirtualisierung und über Container und Solaris-Sons und so weiter.

47:09.751 --> 47:11.554
Hier redet man über Hosted Virtualization.

47:11.574 --> 47:22.870
Das bedeutet im Wesentlichen, Sie haben ein Betriebsystem, was auf Ihren Knochen läuft und da drauf lassen Sie das Virtual Box wie so eine Applikation laufen und innerhalb vom Virtual Box läuft dann ein Gastbetriebssystem.

47:22.890 --> 47:29.800
Und das empfehlen wir Ihnen für den Übungsbetrieb oder für das Herumspielen mit fremden Betriebssystemen auf Ihrer Maschine.

47:32.058 --> 47:37.203
Jetzt reden wir mal ganz kurz darüber, was ist ein Computer?

47:37.243 --> 47:44.631
Das ist eigentlich Sachen oder das sind Themen, die haben Sie beim Holger Kahl schon mal gehört.

47:44.691 --> 47:55.843
Ich weiß so halbwegs, was der Holger Kahl erzählt, weil lust derweise zu der Zeit, als ich Assistent war bei der Humboldt, bevor ich hierher kam, hat der gleiche Holger Kahl dort promoviert als Doktorand.

47:55.883 --> 48:00.748
Und wir waren in einem Rechenarchitektur Fachgebiet und haben dort Übungsbetrieb gemeinsam gemacht.

48:01.387 --> 48:17.123
Also von daher, ich weiß, wenn man fragt, wissen Sie das, dann werden Studierende niemals sagen ja, sondern sie werden bestenfalls schweigen und vielleicht auch aktiv sagen nein.

48:17.143 --> 48:18.364
Sicher ist sicher.

48:18.384 --> 48:24.030
Also nach dem Schema machen wir hier so ein bisschen Redundanz.

48:24.050 --> 48:26.112
Wenn Ihnen das zu langweilig ist, geben Sie mir ein Zeichen.

48:27.425 --> 48:34.163
Also, ein Rechner, da haben wir Hardware, dann haben wir ein Betriebssystem, dann haben wir Anwendungsprogramme und dann haben wir Nutzer.

48:34.203 --> 48:41.502
Anwendungsprogramme, Compiler, Webbrowser, Entwicklungswerkzeuge, Hardware, Speicher, Prozessor, I.O.

48:43.051 --> 48:47.519
Es gibt überhaupt drei zentrale Größenordnung, die auch der Kern bedienen muss.

48:47.559 --> 48:52.828
Das ist nämlich die Speicherverwaltung, das ist die Prozessverwaltung oder Prozess-Soar-Verwaltung.

48:52.868 --> 48:56.555
Und es ist noch was Drittes, das ist Interprozess-Kommunikation.

48:56.595 --> 48:59.821
Also wir reden mit anderen.

48:59.841 --> 49:03.507
Weil dann können wir die weiteren Dienste im Userland hinbauen als Extra-Server.

49:06.895 --> 49:10.691
Das ist ein ganz altes Bild, so ein Computer werden Sie heute nicht mehr kaufen können.

49:10.751 --> 49:13.623
Aber was sehen wir hier?

49:13.643 --> 49:15.792
Wir sehen hier den neuen manchen Flaschenhals.

49:18.151 --> 49:22.239
Ich frag nicht, Sie haben alle vom Neumannschen Flaschenhals gehört schon.

49:22.279 --> 49:34.603
Das war die Geschichte, dass ja jede Instruktion und die zugehörigen Daten durch diesen schmalen Fahrt zwischen CPU und Speicher müssen.

49:34.663 --> 49:40.935
Und wir sehen dieser schmale Fahrt, der ist hier sogar noch gemeinsam benutzt durch die ganzen Geräte.

49:40.915 --> 49:53.213
Das heißt, wir haben nur einen Prozessor erst mal und beim Speicherzugriff musste er aber trotzdem mit dem Plattenkontroller und dem Grafikadapter im Wettstreit stehen.

49:53.693 --> 50:02.506
Das heißt, wir haben das Thema Verstopfung oder Contention auf dem System Bus als ein großes Problem.

50:02.546 --> 50:07.694
Eine CPU, ein Kern.

50:07.734 --> 50:09.336
Heute haben wir multiprozessor-Systeme.

50:11.324 --> 50:19.545
Wenn Sie einen Standard-Notbuch vor sich haben, was schätzen Sie, wie viele Verarbeitungseinheiten, wie viele Prozessoren verandert sind?

50:22.698 --> 50:37.915
Da kommen wir an so eine Zahl, Größenrundung 20, weil beispielsweise der Tastaturkontroller ein eigener Prozessor ist oder der Controller für das Speichersystem, also für den Storage, für die Festplatte oder für die SSD und so weiter.

50:37.955 --> 50:45.904
Wir haben aber auch noch das Phänomen, dass wir entweder mehrere physische Prozessoren haben oder eben Multikor.

50:45.884 --> 50:54.780
Das heißt, alle 18 Monate wird sich die Zahl der Transistoren auf der Hardware verdoppeln ungefähr.

50:56.026 --> 51:01.475
Es hat über eine lange Zeit dazu geführt, dass die Prozessoren einfach leistungsfähiger wurden.

51:01.495 --> 51:04.380
Heute haben wir die sogenannte Powerwall.

51:04.420 --> 51:09.728
Das heißt, wir kriegen einfach nicht mehr Strom und mehr Energie in den Prozessor rein bzw.

51:09.768 --> 51:11.091
wieder raus.

51:11.111 --> 51:18.102
Wenn man sich die Temperaturverteilung anguckt, schon seit dem Pentium ist ein Prozessor ungefähr so heiß wie eine Herdplatte.

51:18.723 --> 51:27.382
Und beim Italien und später sind wir in der Größenordnung von einer nuklearen Kettenreaktion, was die Energie dichter auf den Prozessor angeht.

51:27.762 --> 51:30.508
Das heißt, wir können da wirklich nicht mehr Energie reinführen.

51:30.548 --> 51:33.114
Was machen wir mit den zusätzlichen Transistoren?

51:33.415 --> 51:38.706
Wir kriegen immer noch durch die Rechenarchitektur alle 18 Monate Transistoren geschenkt.

51:39.192 --> 51:44.204
Und die Lösung besteht halt darin, dass wir sagen, wir bauen mehrere, wir bauen erst mal Caches.

51:44.224 --> 51:50.579
Caches sind einfach, Speicher ist nämlich von der Struktur einfach aufgebaut, können wir sehr viel hinbauen.

51:50.599 --> 51:53.927
Allerdings haben Caches eine begrenzte

51:54.937 --> 51:56.339
begrenzten Nutzen.

51:56.359 --> 52:05.814
Sie haben vielleicht schon mal von der 90-Prozent-Regel gehört, ein Programm verbringt 90 Prozent seiner Zeit in 10 Prozent des Kodes.

52:05.874 --> 52:12.063
Das heißt, wenn Sie ein langes Programm geschrieben haben und da haben Sie ein Hilfesystem programmiert und so weiter, es wird nie jemand benutzen.

52:12.103 --> 52:17.772
Aber der Hauptfaden in dem Programm, der ist nur 10 Prozent des Kodes und der wird dauernd benutzt.

52:17.752 --> 52:22.802
Das heißt, Cash ist endlos groß zu machen, hat irgendwann keinen Sinn mehr.

52:22.842 --> 52:25.807
Dann ist die Frage, was machen wir jetzt mit den weiteren Prozessoren?

52:25.827 --> 52:28.953
Und da kann man drauf, da bauen wir neue Verarbeitungseinheiten.

52:29.334 --> 52:41.076
Und jetzt kann man, haben Sie vielleicht auch schon gehört von dem Wort Instruction Level Parallelism oder Instruktionsparallelität, wir können ja mit einer Instruktion

52:41.933 --> 52:45.983
mehrere Daten verarbeiten, wir können mehrere Instruktionen gleichzeitig verarbeiten.

52:46.003 --> 52:57.951
Das können wir erst mal innerhalb einer Verarbeitungseinheit machen, das ist also ein Weg, da redet man dann von Pipelining, das man also sagt, während ich die erste Instruktion ausführe, kann ich die nächste ja schon mal laden und

52:58.184 --> 53:00.667
Dann kann ich die Dritte vielleicht auch schon anfassen.

53:00.687 --> 53:01.909
Das geht begrenzt.

53:01.929 --> 53:08.978
Pipelines mit einer Größe mehr als sieben oder acht haben ihre Probleme, weil Abhängigkeiten zwischen Instruktionen bestehen können.

53:08.998 --> 53:12.763
Nicht mal muss auf die Ergebnisse der ersten Instruktion warten, bevor man weiter machen kann.

53:12.823 --> 53:14.705
Also haben wir dort auch wieder ein Limit.

53:14.725 --> 53:21.915
Und was dann übrig bleibt, ist, dass wir sagen, okay, nächste Idee noch, wir machen einfach Verarbeitungseinheiten, Ritt und Dant.

53:21.935 --> 53:25.980
Also arithmetische logische Einheit, bauen wir nicht einmal hin, sondern vielleicht fünfmal oder viermal.

53:26.230 --> 53:29.453
Gleitkommereinheiten bauen Zäume auf und so weiter.

53:29.473 --> 53:36.701
Also man kann da erst mal im Prozess eine ganze Menge machen, aber dann kommt man an einem Punkt, wo man sagt, wir müssen jetzt weitere Kerne hinbauen.

53:36.721 --> 53:50.176
Und jetzt sind wir als Betriebssystem natürlich dran, weil die Verwaltung von mehreren Prozessoren, das bedeutet ja, dass wir mehreres Rätst gleichzeitig laufen lassen, das wird dann in Software gemacht, das ist dann schwierig.

53:51.537 --> 53:51.597
Und

53:51.577 --> 53:55.385
Sie sehen also der Begriff heißt Software Hardware Co Design.

53:55.445 --> 54:02.900
Wir sind hier an der Stelle, wo die Rechner Architektur eigentlich selber nicht mehr weiter weiß und Hilfe braucht von den Software Leuten um drüber.

54:02.920 --> 54:03.882
Und dann gibt es noch ein Ding.

54:03.922 --> 54:10.716
Das heißt Dynamics Frequency Invalid Scaling DFVS.

54:10.696 --> 54:15.368
Das heißt im Wesentlichen, wir schalten ab.

54:15.388 --> 54:23.068
Wenn wir gar nicht mehr weiter wissen, weil die Software, die die Lösung bereitstellen soll, viele Verarbeitungseinheiten gleichzeitig bedienen.

54:23.318 --> 54:29.506
Diese Software, die ist unter Umständen alt und hat gar keine Ahnung davon, dass es mehrere Prozessoren gibt.

54:29.526 --> 54:33.010
Gucken Sie sich eine Textverarbeitung an.

54:33.030 --> 54:35.994
Diese Software, die möchte einfach nur, dass der Prozessor schneller ist.

54:36.014 --> 54:47.048
Und dann machen wir eins, dann werden wir auf der Hardware alles Überschüssige abschalten und werden jetzt den Teil, den wir wirklich benutzen, übertakten.

54:47.088 --> 54:48.870
Das, was der Spiele

54:48.850 --> 54:53.083
Prozessor aufmacht, einfach overclocking.

54:53.123 --> 54:57.898
Das heißt jetzt hier Dynamic Frequency und Volger Scaling.

54:58.216 --> 55:05.427
Und dann gibt es noch so ein Phänomen, das heißt Dark Silikon, also schwarzes Silikon, schwarze Transistor und abgeschaltet.

55:05.908 --> 55:09.374
Sie frage, wie kann man denn Teile von dem Prozessor eigentlich abschalten?

55:09.394 --> 55:16.525
Wenn man das per Strom macht, also wenn man da die Stromversorgung kappt, dann ist es schwierig, dauert viel zu lange wieder einzuschalten.

55:16.545 --> 55:20.651
Was man aber machen kann, man kann das Taksignal weghalten.

55:20.711 --> 55:23.616
Es gibt ja einen Takt, nach dem die Prozessoren funktionieren.

55:24.963 --> 55:30.872
und dieses Tagssignal muss sich dann an gewisse Teile der Verarbeitungseinheit nicht weiterreichen.

55:30.892 --> 55:33.235
Also Ende vom Lied.

55:33.255 --> 55:42.128
Die Hardware macht hier eine ganze Menge Tricks, aber am Ende muss das Betriebssystem sich um mehrere Verarbeitungseinheiten kümmern und damit umgehen können.

55:44.572 --> 55:47.858
Und Sie merken, das wird am Ende auf Sie zurückfallen.

55:47.898 --> 55:51.284
Noch so ein Grund, bei Betriebssystemen mal aufzupassen.

55:51.304 --> 55:58.677
Denn früher oder später wird das Betriebssystem das nicht mehr alleine wegbekommen, sondern Sie müssen das in Ihre Anwendungssoftware adressieren.

55:58.697 --> 56:00.940
Mehreres Rätts programmieren.

56:00.961 --> 56:04.607
Wenn Sie das in C machen wollen, wissen Sie es noch nicht, wie es geht.

56:04.627 --> 56:07.592
Kriegen Sie hiermit, wenn Sie das in Python machen wollen,

56:08.247 --> 56:13.097
Ganz schlecht, weil Python hat eine Ausführungsumgebung, die Singles redet.

56:13.157 --> 56:20.793
Also die Wahl der Proamiersprache für ihre Anwendung hat auf einmal Auswirkungen darauf, wie effizient die Programme laufen, wie gut der Computer funktioniert.

56:22.517 --> 56:27.387
Und jetzt können wir sagen, alle sind die gleichen oder wir haben einen Prozessor, der eine spezielle Rolle spielt.

56:29.611 --> 56:32.538
Was ist der Unterschied zwischen multiprocessing und multicore?

56:32.558 --> 56:37.108
Bei multiprocessing sind die gemeinsamen Teile geringer.

56:37.329 --> 56:40.596
Man redet dann von sogenannten shared-nassing-Architekturen.

56:40.616 --> 56:45.207
Und hier haben wir einen gemeinsam benutzen Level-2-Cache.

56:45.187 --> 56:47.371
Warum ist das ein spannendes Ding?

56:47.411 --> 56:54.362
Na ja, je näher wir an dem CPUkehren sind und so schneller ist der Zugriff auf den Speicher natürlich möglich.

56:54.403 --> 57:01.795
Aber gleichzeitig ist es jetzt auf einmal so, wenn ich hier Daten modifiziere, hier kriegt der da drüben das dann mit.

57:01.775 --> 57:07.023
oder muss ich die erst hier unten modifizieren, wenn der auf die gleichen Daten zugreift.

57:07.063 --> 57:21.505
Man spricht also von Riot-Shoe, wenn man Systeme hat, die direkt in Hauptspeicher schreiben und man spricht von Cache-Kohärenz-Protokollen, wenn man dafür sorgt, dass die Daten im Cache für alle Prozessoren gleichermaßen zugänglich sind.

57:21.485 --> 57:38.110
Und um den ganzen noch eins drauf zu setzen, nun mal non-uniform memory access architecture, wenn sich heute Server Systeme angucken und das ist ein kleiner Server mit vier Sockeln, dann ist es so, dass es hier eine Verbindung gibt bei Intel heißt das QPI, QuickPass Interconnect.

57:39.220 --> 57:44.769
Und den Speicher, den großen Speicher in Ihrem Computer, den bindet man nicht mehr über einen Bus an eine CPU ran.

57:44.809 --> 57:45.770
Warum?

57:45.790 --> 57:51.178
Speicherverstopfung war das Thema, sondern den Speicherbinden war an verschiedene Prozessoren an.

57:51.259 --> 57:55.084
Und das Ganze ist aber immer noch ein System mit einem einheitlichen Speicher.

57:55.125 --> 57:59.812
Das heißt, wenn Sie hier rechnen, dann können Sie sehr gewohl auf den Speicher hier drüben zugreifen.

57:59.872 --> 58:01.815
In dem Fall wird eine Kommunikation stattfinden.

58:01.835 --> 58:04.519
Diese CPU wird ungefähr 10 Prozent Ihrer

58:04.499 --> 58:11.859
Fähigkeiten zur Seite legen als Reserve, einfach nur um solche Zugriffe hier weiter zu schicken.

58:11.879 --> 58:14.205
Und dann können Sie auf die Saaten zugreifen.

58:18.910 --> 58:22.496
ist multiprocessing das gleiche wie multi-threaded.

58:22.516 --> 58:30.570
Also multi-threading ist zunächst ein Charakteristikum der Software, dass ich mit mehreren Strats programmiere.

58:30.610 --> 58:32.894
Ein Strat, was ist das überhaupt, ist ein Kontrollfluss.

58:32.914 --> 58:41.830
Also wenn man so will, ist eine Funktion, die ausgeführt wird mit einem eigenen Stack, mit einem eigenen Programm-Counter und so weiter.

58:41.810 --> 58:45.217
Jetzt kann ich in meinem Programm Ihres Rätts haben.

58:45.237 --> 58:50.267
Jetzt können diese Rätts auf einem Einprozessorsystem ausgeführt werden.

58:50.307 --> 58:53.614
Dann werden sie reihum ausgeführt, dann redet man von Nebenläufigkeit.

58:53.654 --> 58:56.740
Mal ist der eine dran, mal ist der nächste dran, mal ist der übernächste dran.

58:56.760 --> 59:00.949
Jetzt können sie ausgeführt werden auf einem System, was zwei Verarbeitungseinheiten hat.

59:00.929 --> 59:04.033
Dann können Zweisrätts parallel laufen gleichzeitig.

59:04.073 --> 59:06.015
Also parallel heißt gleichzeitig.

59:06.035 --> 59:10.500
Und der dritte, vierte, fünfte nicht, die müssen sich wieder abwechseln.

59:10.560 --> 59:11.962
Ist das dann multiprocessing?

59:11.982 --> 59:14.405
Ja, das nennt man multiprocessing.

59:14.425 --> 59:16.447
Oder multiprogrammierung.

59:16.467 --> 59:18.389
Gibt noch multiprocessing, multiprogrammierung.

59:18.429 --> 59:23.695
Bei multiprogrammierung redet man von zwei Programmen, die gleichzeitig auf zwei Prozessoren laufen.

59:23.735 --> 59:25.117
Auch das ist möglich.

59:25.137 --> 59:28.641
Ich kann ein Programm schreiben, Zweisrätts laufen gleichzeitig auf zwei Prozessoren.

59:28.925 --> 59:41.879
Ob diese zwei Prozessoren jetzt in getrennten Gehäusen auf der Maschine sitzen oder in einem Prozessor als Chorus versammelt sind, ist aus Betriebssystemes sich kein Unterschied.

59:41.899 --> 59:44.161
Und ja, Punkt.

59:44.181 --> 59:52.350
Also Multi-Prozessing ist ein Rechenarchitekturwort, Multi-Chore ist ein Rechenarchitekturwort, SRED ist ein Softwarewort.

59:55.722 --> 01:00:13.840
Genau, und hier um das Ganze noch eins weiter zu treiben, wie gesagt, wenn man die ganze Computer-Architektur nicht mehr in einem Prozessor unterbringt, sondern Systeme einfach gewisse Größen überschreiten, Stichwort Skalierbarkeit, dann baut man halt sowas auf.

01:00:13.860 --> 01:00:21.527
Spannend deshalb, weil natürlich klar ist, der Zugriff auf den Speicher hier oben, der geht schneller als der Zugriff auf den Speicher hier unten.

01:00:21.507 --> 01:00:27.657
Und es gibt noch ein weiteres Phänomen, wenn alle so was machen hier, dann haben wir eine Verstopfung im Verbindungsnetzwerk.

01:00:27.697 --> 01:00:35.330
Das heißt, in Abhängigkeit davon, welche wie ein Programm auf diesen Prozessoren landet, läuft es unterschiedlich schnell.

01:00:35.370 --> 01:00:43.603
Das ist ein großes Performance-Engineering-Thema.

01:00:43.643 --> 01:00:46.568
Jetzt haben wir über Programme geredet.

01:00:46.588 --> 01:00:48.291
Das waren Programme gleich noch.

01:00:48.608 --> 01:00:51.273
Ein Programm ist ein Datei auf der Festplatte.

01:00:51.293 --> 01:00:53.317
Das ist sozusagen tot.

01:00:53.337 --> 01:00:54.940
Und dann haben wir Prozesse.

01:00:54.960 --> 01:00:58.707
Ein Prozess ist ein Programm in Ausführung.

01:00:58.827 --> 01:01:03.435
Und dann haben wir außerdem gesagt, in einem Prozess gibt es mindestens eins Red.

01:01:03.496 --> 01:01:06.201
Das haben wir so deutlich noch nicht gesagt, aber das sage ich jetzt.

01:01:06.221 --> 01:01:08.244
Das heißt, einen Kontrollfluss.

01:01:08.284 --> 01:01:11.290
Aber es kann in einem Prozess auch mehrere Kontrollschlüsse geben.

01:01:11.310 --> 01:01:12.372
Das sind am ehesten Reds.

01:01:13.043 --> 01:01:18.052
Wie man Kontrollflüsse programmiert, hängt an der Programmiersprache, liegt an der Programmiersprache, die Sie verwenden.

01:01:18.232 --> 01:01:19.474
Und an der Stelle sind Sie alle nackig.

01:01:19.534 --> 01:01:21.858
Das haben Sie noch nicht groß geübt.

01:01:21.878 --> 01:01:27.528
Jetzt gibt es Programmiersprachen, die das besser können und leichter dafür geeignet sind.

01:01:27.548 --> 01:01:35.963
Zum Beispiel Java ist so eine Sprache, in der Sie einfach SRED-Objekte als Kinder der Klasse Rannebild erzeugen können.

01:01:35.983 --> 01:01:38.427
Da schreiben Sie eine Funktion hin.

01:01:38.407 --> 01:01:43.955
Dann wird auch die Synchronisierung einfacher gemacht, weil es dafür Sprachkonstrukte gibt.

01:01:43.996 --> 01:01:51.467
Gibt es andere Sprachen, so wie C, wo es nicht in die Sprache eingebaut ist, wo man sich mit Bibliotheken auseinandersetzen muss.

01:01:54.832 --> 01:02:00.701
Also wir sind jetzt in der Lage, Programme auszuführen als Prozess in den Prozessen vielleicht mehrers setz.

01:02:00.721 --> 01:02:04.667
Und zu dem Prozess gehört noch was anderes, nämlich ein Speicherbereich.

01:02:05.272 --> 01:02:09.197
Ist die Frage, wie teilen wir den Speicher auf?

01:02:09.217 --> 01:02:12.441
Auch sehr viel Details, auf die wir noch eingehen werden.

01:02:12.481 --> 01:02:18.149
Aber stellen wir uns einfach vor, wir haben getrennte Speicherbereiche für verschiedene Prozesse.

01:02:18.169 --> 01:02:23.095
Und jetzt wollen wir natürlich, dass wenn das eine Programm ein Fehler hat, das Nachbarprogramm nicht betroffen ist.

01:02:23.135 --> 01:02:27.261
Das heißt, wir wollen diese Speicherbereiche gegeneinander schützen.

01:02:27.281 --> 01:02:28.662
Und die Frage ist, wie macht man das?

01:02:28.682 --> 01:02:33.709
Wenn man das im User Mode macht, also wenn man das die Programme selber machen lässt, dann hat man keinen wirklichen Schutz.

01:02:34.533 --> 01:02:37.379
sondern das ist eine Aufgabe des Betriebssystems.

01:02:37.399 --> 01:02:41.527
Und jetzt ist die Frage, wie kann sich das Betriebssystem gegenüber den Nutzerprogrammen schützen?

01:02:41.547 --> 01:02:43.491
Und die Antwort ist, wir brauchen wieder ein bisschen Hardware.

01:02:44.493 --> 01:02:47.238
Wir brauchen nämlich Protection Levels.

01:02:47.258 --> 01:02:52.348
Wir brauchen eine Unterstützung durch den Prozessor.

01:02:52.368 --> 01:02:55.815
Und da gibt es das Prozessor-Statteswort.

01:02:56.403 --> 01:03:01.109
indem in einem Bit codiert ist, sind wir im User oder im Corner Mode.

01:03:01.129 --> 01:03:07.456
Bei der Wax, hatte ich vorhin schon erzählt, waren es zwei Bits, da hatten wir also vier Modi, aber heute haben wir wenigstens zwei.

01:03:07.536 --> 01:03:12.282
Und wir sagen im User, da sind wir nicht privilegiert, im Corner Mode sind wir privilegiert.

01:03:12.522 --> 01:03:23.355
Und wir können jetzt Speicherbereiche damit also taggen, wir können dem eine Markierung geben und sagen, dieser Speicherbereich ist nur im Corner Mode schreibbar und jener Speicherbereich ist im User Mode schreibbar.

01:03:23.926 --> 01:03:49.274
Auf die Weise können wir jetzt Programme, die laufen, gegeneinander isolieren, indem wir denen jeweils ein Speicherbereich zuweisen und die dürfen nicht in den fremden Speicherbereich fassen, weil wir ihnen den Zugriff nur erlauben, wenn im Körner die richtigen Redirektionspointer gesetzt sind letztlich.

01:03:49.314 --> 01:03:53.258
Das heißt aber auch, wenn wir im Körner unterwegs sind, gibt es keinen Schutz mehr.

01:03:53.795 --> 01:03:57.001
Also wenn im Kornel was schief geht, dann geht es richtig schief.

01:03:59.165 --> 01:04:03.053
Und jetzt können wir uns noch mal erinnern an dieses Bild von vorhin, was alles im Kornel läuft.

01:04:03.073 --> 01:04:04.997
Da waren zum Beispiel die Gerätetreiber.

01:04:05.037 --> 01:04:07.522
Das haben Sie sicherlich auch schon erlebt.

01:04:07.542 --> 01:04:09.205
Sie installieren ein neues Gerät.

01:04:09.472 --> 01:04:11.316
Und der Treiber hat eine Macke.

01:04:11.356 --> 01:04:21.937
Treiber sind Software, die schlecht getestet ist, die häufig kurzfristig entwickelt wird, die sich häufig ändert im Vergleich zu einem Betriebssystem.

01:04:21.957 --> 01:04:26.265
Das heißt Fehler finden sich häufig in den Treibern.

01:04:28.304 --> 01:04:30.187
Es gibt zwei Möglichkeiten, damit umzugehen.

01:04:30.227 --> 01:04:33.552
Erstens, wir lassen die Treiber nicht im Kernel-Mode laufen, sondern auch im User-Mode.

01:04:33.572 --> 01:04:37.157
Das ist von der Architektur ein bisschen aufregend, kann man aber machen.

01:04:37.177 --> 01:04:40.542
Wenn wir sie im Kernel-Mode laufen lassen, dann müssen wir sie gut testen.

01:04:40.983 --> 01:04:48.574
Und dafür gibt es halt auch wieder eine Software-Landschaft, eine Werkzeuglandschaft in der Windows-Betriebssystem-Familien, in anderen Familien auch.

01:04:49.027 --> 01:04:58.221
in Form von dem Driver Verifier, dass man also sagt, erstens das Ding ist getestet, zweitens wird vertrauen dem, weil es hat einen Zertifikat, das kommt garantiert vom Hersteller.

01:04:58.242 --> 01:05:03.510
Microsoft hat das schon mal drauf geguckt und drittens, während des Betriebs, können wir das Ding nochmal unter Stress setzen.

01:05:03.550 --> 01:05:08.277
Wir können also sagen, Speicherallokationen im Driverschlagen fehlen.

01:05:10.481 --> 01:05:16.350
Wir gucken nach, ob der Puffer Überläufe hat, indem wir rechts und links von seinem Speicherbereich Bereiche machen, die garantiert nicht zugruffähig sind.

01:05:16.668 --> 01:05:17.289
Und so weiter.

01:05:17.309 --> 01:05:23.634
Auf die Weise, Sie haben vielleicht von Tests getrieben, das Softwareentwicklung schon mal gehört, auf die Weise findet man Fehler.

01:05:23.654 --> 01:05:26.636
Und die Fehler, die man einmal gefunden hat, die werden kein zweites Mal auftreten.

01:05:27.537 --> 01:05:40.488
Das heißt, inzwischen haben die Betriebssysteme eine Infrastruktur rund um die Treiber aufgebaut, die auch dieses Software qualitativ verbessern, sodass dieses Problem Fehler im Kernelmut kein großes Problem mehr ist.

01:05:43.030 --> 01:05:46.253
Jetzt werden Sie sagen, alles klar, ich kann jetzt Programme schreiben.

01:05:47.667 --> 01:05:52.759
Mein Hello World, aber wie bringt denn Hello World die Zeichen auf den Bildschirm?

01:05:52.779 --> 01:05:55.786
Dazu muss es doch mit der Computer Hardware reden.

01:05:55.846 --> 01:06:00.076
Und diese Computer Hardware wird doch durch den Kernel verwaltet.

01:06:00.137 --> 01:06:03.685
Also wie komme ich von meinem Userprogramm überhaupt in den Kernel Mode?

01:06:04.087 --> 01:06:08.213
Und die Antwort ist, dafür gibt es SystemAufrufe, SystemCalls.

01:06:08.233 --> 01:06:14.382
Und diese SystemAufrufe, die müssen vom User-Modus in den Kernel-Modus umschalten.

01:06:14.402 --> 01:06:23.094
Und es geht durch spezielle Instruktionen, SysEnter, SysCall, SupervisorCall, die heißen je nach Prozessortypen unterschiedlich.

01:06:23.154 --> 01:06:28.862
Es geht aber auch durch das Auslösen eines Innenrats, also eines sogenannten Software-Traps.

01:06:28.960 --> 01:06:31.023
Dann kommt man nämlich in den Kernel Modus.

01:06:31.043 --> 01:06:33.828
Das ist ein sicheres Gateway.

01:06:33.888 --> 01:06:39.056
Warum das ein sicherer Weg ist, vom User in den Kernel umzuschalten, müssen wir noch diskutieren.

01:06:39.076 --> 01:06:41.440
Und wie kommt man zurück vom Kernel in User?

01:06:41.460 --> 01:06:42.241
Ganz einfach.

01:06:42.261 --> 01:06:45.005
Wir müssen dieses Bit hier im Prozess der Statteswort einfach löschen.

01:06:45.025 --> 01:06:46.227
Dann sind wir wieder im User.

01:06:49.092 --> 01:06:51.135
Und hier ist das Ganze noch mal grafisch veranschaulicht.

01:06:51.155 --> 01:06:54.600
Wir haben ein Prozess, der macht irgendwas, der macht ein Systemaufruf.

01:06:54.620 --> 01:06:58.486
Hier wird ein Trepp ausgelöst und damit sind wir in dem Kernel-Mode.

01:06:58.506 --> 01:07:01.270
Der Trepp ist ein Software-Interrupt.

01:07:01.310 --> 01:07:04.215
Jetzt führen wir den Systemaufruf im Kernel aus.

01:07:04.235 --> 01:07:06.038
Welchen Systemaufruf wollen wir ausführen?

01:07:06.058 --> 01:07:08.481
Woher weiß denn der Kernel das eigentlich?

01:07:08.501 --> 01:07:16.213
Die übliche Weg, wir übergeben eine System Call Nummer, eine System Service Number in einem Register der CPU.

01:07:16.852 --> 01:07:21.897
Und dann weiß der hier oben, der wollte einen 20 ausführen.

01:07:21.917 --> 01:07:24.780
Und der weiß hier unten, er soll einen 20 ausführen.

01:07:24.840 --> 01:07:28.845
Und dann macht er es halt, gibt die Daten zurück.

01:07:28.865 --> 01:07:31.447
Einfach, oder?

01:07:31.487 --> 01:07:37.133
Gar nicht einfach, weil in Wirklichkeit kann hier zwischendurch was passieren.

01:07:37.153 --> 01:07:40.917
Das kann sein, dass der System aufrufen eine ganze lange Zeit dauert.

01:07:40.937 --> 01:07:43.720
Und in der Zwischenzeit ist schon der nächste Prozess da oben dran.

01:07:44.712 --> 01:07:50.948
Das heißt, wir können die Ergebnisse als Betriebssystem gar nicht einfach zurückgeben, weil der Prozess da oben, der ist gar nicht mehr aktiv.

01:07:50.988 --> 01:07:55.119
Wir müssen warten, bis der wieder dran kommt und dann muss er sich die Daten abholen.

01:07:55.179 --> 01:08:01.455
Das heißt dieser Pfeil, der ist in Wirklichkeit implementiert so, dass der nämlich nach unten geht und dann die Daten hoch holt.

01:08:02.009 --> 01:08:11.501
Das ist bei sogenannten Langsam- oder langen Systemaufrufen so, diese Asynchron abgearbeitet werden, sowohl in Windows wie auch in Linux, wie auch in Unix, in jedem System.

01:08:11.521 --> 01:08:16.667
Bei schnellen Systemaufrufen ist es so, dass die Unix-Systeme die einfach machen.

01:08:16.687 --> 01:08:20.172
Die lassen keinen Prozesswechsel zu.

01:08:20.192 --> 01:08:24.157
Die Asynchron-Systeme Windows Form S, die sind da anders.

01:08:24.177 --> 01:08:27.561
Hier kann so ein Prozesswechsel, der hier dargestellt ist, immer stattfinden.

01:08:30.005 --> 01:08:32.508
Was ist ein Interrupt?

01:08:32.548 --> 01:08:35.372
Das ist auch ein GDS-Thema, glaube ich.

01:08:35.412 --> 01:08:37.114
Und es klingt so ganz cool.

01:08:37.134 --> 01:08:38.436
Der Rechner rechnet so vor sich hin.

01:08:38.596 --> 01:08:40.919
Ich kann ihn jederzeit unterbrechen.

01:08:40.939 --> 01:08:41.961
Nee, natürlich nicht.

01:08:41.981 --> 01:08:49.150
Sie erinnern sich, da gab es doch mal diese Register-Transfer-Language und dann gab es mal die Diskussion, wie Instruktionen ausgeführt werden.

01:08:49.170 --> 01:08:54.557
Und am Anfang jeder Instruktion gucken wir, ob eine Interrupt-Request-Leitung ein Signal anliegt.

01:08:54.597 --> 01:08:56.940
Und wenn dieses Signal anliegt, dann wäre wir eben nicht

01:08:57.258 --> 01:09:05.471
den Obcode holen, ins Instruktionsregister laden und verstehen, was los ist, die Instruktion ausführen, sondern dann werden wir verzweigen.

01:09:05.491 --> 01:09:10.138
Dann werden wir nämlich in die Interab-Service Tabelle springen und dort eine Funktion ausführen.

01:09:11.199 --> 01:09:16.568
Also Interab ist sozusagen auf einer höheren Ebene eine Unterbrechung.

01:09:16.588 --> 01:09:21.375
In Wirklichkeit ist es bei jeder Instruktion mal kurz nachgucken, was hier los ist.

01:09:21.355 --> 01:09:25.841
Und auf die Weise können wir Systemaufrufe ausführen.

01:09:25.861 --> 01:09:28.705
Der ganze Kern ist Interrupt getrieben.

01:09:28.825 --> 01:09:32.850
Und wer kann alles Interrupt schicken?

01:09:32.870 --> 01:09:39.719
Wir haben gerade von Software Interrupts geredet, von den Traps, aber die andere Quelle von Interrupts sind natürlich Geräte, die Hardware.

01:09:39.779 --> 01:09:46.688
Also wir sagen der Festplatter, bitte liest mir mal folgende Sektoren und dann sagt ihr alles klar, ich schick dir ein Signal, wenn ich fertig bin.

01:09:47.123 --> 01:09:54.473
und das Netzwerkgerät macht genau dasselbe und so weiter.

01:09:54.533 --> 01:09:56.536
Wir müssen den CPU-Zustand sichern.

01:09:56.556 --> 01:09:58.258
Wo ist der CPU-Zustand?

01:09:58.278 --> 01:10:01.502
Der ist in Registern und im Programmzähler.

01:10:01.542 --> 01:10:08.452
Jetzt werden Sie sagen, aha, der Intel, der hat irgendwie 16 Register, die kann ich leicht sichern, ist nicht schwer.

01:10:08.472 --> 01:10:12.557
Wenn Sie sich den Italium angucken als Prozessor, der hat 128 Register.

01:10:13.162 --> 01:10:18.049
Wenn Sie 128 Register sichern wollen, dann braucht es ein Haufen Zeit.

01:10:18.089 --> 01:10:21.613
Das heißt, Interabverarbeitung wird auf einmal ganz langsam.

01:10:21.653 --> 01:10:32.788
Das heißt, die großen Prozessoren, die großen Risk-Prozessoren, die sichern nicht mehr alle Register, sondern nur noch einen kleinen Zahl, fünf Register und den Programmcounter.

01:10:32.828 --> 01:10:42.882
Und wenn man mehr Register verwenden möchte in dem Interabcode, dann ist man selber dafür zuständig, als Software wiederum diese Register zu retten.

01:10:43.267 --> 01:10:54.525
Aber Implementierungsdetail, wir merken uns einfach, wenn Interapt auftritt, dann speichern wir den alten Zustand des Prozessors, machen Interabverarbeitung und lassen dann den Prozessor an der gleichen Stelle weiterarbeiten.

01:10:57.249 --> 01:11:01.837
Ein und Ausgabe, auch ein Thema in Betriebssysteme 2.

01:11:01.877 --> 01:11:08.227
Wir wollen die CPU und das IOSystem gleichzeitig ausführen.

01:11:08.267 --> 01:11:08.768
Warum?

01:11:09.997 --> 01:11:14.527
Sie erinnern sich, da war Raum auf der Welt für fünf Computer.

01:11:14.547 --> 01:11:16.191
Computer sind furchtbar teuer.

01:11:16.231 --> 01:11:19.758
Das war also die erste Maxime beim Gestalten von Betriebssystemen.

01:11:19.798 --> 01:11:24.208
Wir wollen die Computer so effizient wie möglich ausnutzen und eine naheliegende Idee ist,

01:11:24.847 --> 01:11:30.538
Wenn Sie sich Ihre Programme angucken, dann sind diese Programme so, dass Sie eine Weile rechnen und dann machen Sie wieder I.O.

01:11:30.558 --> 01:11:32.622
und dann rechnen Sie wieder eine Weile und dann machen Sie I.O.

01:11:32.642 --> 01:11:34.806
Es gibt also sogenannte Compute Burst und I.O.

01:11:34.826 --> 01:11:35.868
Burst.

01:11:35.928 --> 01:11:37.932
Und jetzt ist die Idee, dass wir die überlagern.

01:11:37.952 --> 01:11:41.859
Dass wir sagen, das eine Programm, das soll rechnen, das andere macht der Weile I.O.

01:11:41.899 --> 01:11:43.362
und jetzt tauschen wir beide um.

01:11:44.557 --> 01:11:48.503
Das nennt man dann Multi-Programmierung und wir wollen also I.O.

01:11:48.523 --> 01:11:51.007
und CPU gleichzeitig betreiben können.

01:11:51.067 --> 01:11:59.419
Das heißt, wir müssen uns jetzt Gedanken machen, wie wir diese I.O.-Geräte so weit wie möglich von der CPU entkoppeln.

01:11:59.439 --> 01:12:01.642
Wenn Sie sagen, nee, meine Aufgabe ist ganz anders.

01:12:01.662 --> 01:12:06.329
Ich will ja bloß den Wecker auf Nachtisch programmieren als Embedded-Gerät.

01:12:06.349 --> 01:12:10.435
Und da gibt es keinen anderen Job, außer auf diese Schnarchtaste zu drücken.

01:12:10.475 --> 01:12:12.859
Und immer zu hören, hat gleich schon jemand draufgedrückt.

01:12:13.683 --> 01:12:17.755
Inzwischen muss ich den Zeiger eins weiter drehen, aber das kann ich mit Polling machen.

01:12:17.775 --> 01:12:23.210
Da kann ich den Prozessor dafür verwenden, um ausschließlich immer wieder diese Taste abzufragen.

01:12:23.230 --> 01:12:25.437
In einem Standard Betriebssystem kann ich mir das nicht erlauben.

01:12:25.457 --> 01:12:28.124
Da muss der Prozessor andere Dinge tun.

01:12:28.144 --> 01:12:29.127
Und deshalb kommen wir hier.

01:12:29.107 --> 01:12:39.423
Dazu, dass wir sagen, wir brauchen lokale Puffer für die EU-Operation, wir brauchen Gerätetreiber, also ein Stück Software und wir brauchen noch etwas, das heißt Controller.

01:12:39.443 --> 01:12:40.645
Controller ist ein Stück Hardware.

01:12:41.046 --> 01:12:46.475
Also hier gibt es spezielle Software und spezielle Hardware, die miteinander spielen, damit das Ganze entkoppelt ist.

01:12:46.495 --> 01:12:54.928
Und in der Regel in allen moderneren Rechnern gibt es DMA, das Direkt Memory Access Co-Prozessoren, wo Sie sagen können,

01:12:55.195 --> 01:13:02.044
Nimm mal die Daten und kopiere die mir in Speicher an folgende Stelle und wenn du damit fertig bist, dann schickst mir ein Signal.

01:13:02.064 --> 01:13:07.951
Also wir entkoppeln viele Aufgaben in dem Rechner vom Betriebssystem und von der CPU.

01:13:07.971 --> 01:13:12.437
Das Ganze kann man jetzt wieder Synchron oder Asynchron machen.

01:13:12.477 --> 01:13:20.047
Stellt sich heraus, die meisten Menschen, wir sind gewohnt Synchron zu programmieren.

01:13:20.067 --> 01:13:22.570
Der Algorithmus ist nichts weiter als

01:13:23.343 --> 01:13:29.303
Kochrezept, eine Abfolge von Schritten, die zu einem Ergebnis führen.

01:13:29.363 --> 01:13:34.922
Ich weiß nicht, ob man das anders lernen kann, aber meine Erfahrung ist, wir programmieren Synchro.

01:13:36.202 --> 01:13:40.386
Und die Welt ist aber Asynchronen.

01:13:40.406 --> 01:13:50.236
Wenn Sie rausgucken und sehen die Blätter an dem Baum und die werden vom Wind bewegt, da gibt es keine Synchrone Instanz, die sagt, blatt bewegt dich und die machen das alle so für sich hin.

01:13:50.336 --> 01:13:53.479
Und das ist eine Challenge, die im Betriebssystem auch wieder vorkommt.

01:13:53.499 --> 01:14:05.230
Wir müssen das Synchrone, was der Programmierer erwartet, abbilden auf einen Asynchronen sich verhaltenes System, eine Asynchrone Umgebung, aber auch ein System, das Asynchrone funktioniert.

01:14:05.210 --> 01:14:13.520
Und dann brauchen wir noch die Timer, also den Zeitbegriff.

01:14:13.580 --> 01:14:15.662
Was steckt dahinter?

01:14:15.682 --> 01:14:20.068
Manchmal... Ja, gute Frage.

01:14:20.088 --> 01:14:25.834
Wenn mehrere Programme gleichzeitig auf dem Computer laufen, wie sollen das eigentlich gehen?

01:14:25.854 --> 01:14:29.378
Sollen die so lange laufen, bis sie fertig sind und dann das nächste?

01:14:29.399 --> 01:14:32.382
Sollen die so lange laufen, bis sie freiwillig die CPU aufgeben?

01:14:33.188 --> 01:14:37.914
oder sollen die regelmäßig unterbrochen werden, damit der nächste dran kommt.

01:14:37.954 --> 01:14:49.970
Wenn Sie auf die Idee kommen, Sie wollen die unterbrechen, dann redet man nebenbei von preemptiven Scheduling, also von regelmäßig unterbrechen des laufenden Programms.

01:14:49.990 --> 01:14:52.473
Dann brauchen Sie einen Zeitbegriff.

01:14:52.493 --> 01:14:54.015
Wo kommt der Zeitbegriff her?

01:14:54.417 --> 01:14:57.442
Naja, unser Prozessor ist ja sowieso getaktet.

01:14:57.462 --> 01:15:00.527
Wir haben also einen Crank Wars, wir haben einen Takt in dem Prozessor.

01:15:00.547 --> 01:15:17.455
Jetzt brauchen wir das mitzählen und dann haben wir irgendwie eine Zeit und diesen Timer-Tick oder Clock-Tick, den zählen wir dann hoch und dann sagen wir, liebes Programm, lieber Prozess, du bist jetzt lange genug gelaufen.

01:15:17.475 --> 01:15:18.417
Jetzt ist der nächste dran.

01:15:21.046 --> 01:15:28.843
Jetzt können Sie mal kurz überlegen, wie lang ist denn das Programm, was Sie als letztes geschrieben haben, das längste Programm, was Sie jemals geschrieben haben.

01:15:32.290 --> 01:15:34.836
1.000 Zeilen, 4.000 Zeilen, 10.000 Zeilen.

01:15:36.487 --> 01:15:40.735
Daumenregel 2K passen auf eine A4 Seite.

01:15:40.935 --> 01:15:46.005
Wenn Sie es mal ausgedruckt haben und es waren mehr als 10 A4 Seiten, haben Sie ein Großprogramm geschrieben.

01:15:46.085 --> 01:15:48.750
In der Regel ist es so ein, zwei Seiten.

01:15:48.790 --> 01:15:54.481
Also es sind, sagen wir mal, 2K, 4K.

01:15:54.501 --> 01:15:56.044
Was in K ist, müssen wir auch noch darüber reden.

01:15:56.064 --> 01:15:56.605
Kommt noch.

01:15:57.496 --> 01:16:00.581
Und jetzt können wir überlegen, wie viele Instruktionen das wohl sind.

01:16:00.641 --> 01:16:04.126
Aber wir sind im Bereich von ein paar tausend, von ein paar zigtausend Instruktionen.

01:16:04.967 --> 01:16:10.335
Jetzt werden wir sehen, dass unsere Programme in Wirklichkeit viel größer sind, wenn sie ausgeführt werden als das, was sie codiert haben.

01:16:10.355 --> 01:16:19.168
Das liegt daran, dass es ja noch ein Startcode gibt, dass es Bibliotheken gibt, dass es weitere Funktionalität gibt, die herangebunden wird.

01:16:19.188 --> 01:16:20.630
Aber nichtsdestotrotz.

01:16:20.650 --> 01:16:22.653
Wie lange wird dieses Programm brauchen, bis es fertig ist?

01:16:24.336 --> 01:16:27.300
Wer hat sich schon mal gefragt, wie lange läuft denn mein Programm?

01:16:30.419 --> 01:16:32.361
Können Sie das in einer Programmiersprache hinschreiben?

01:16:32.381 --> 01:16:33.503
Nee, können Sie nicht.

01:16:33.523 --> 01:16:39.550
Große Schwäche können Programmiersprachen, können Laufzeit nicht ausdrücken.

01:16:39.590 --> 01:16:43.194
Das hängt sicherlich ab von der Taktfrequenz des Prozessors.

01:16:43.214 --> 01:16:46.458
Wie schnell ist so ein Prozessor heute getaktet?

01:16:46.498 --> 01:16:49.962
3 Gigahertz ist so eine Zahl, auf die man sich eingeschossen hat.

01:16:49.982 --> 01:16:55.228
Die Mainframe, die kann 5,3, ist schon klar, die können mehr, aber die hat halt auch eine Wasserkühlung.

01:16:55.647 --> 01:16:58.170
damit sie die Hitze wieder rauskriegen.

01:16:58.210 --> 01:17:02.714
Also, wir können diese... Wie viele waren es?

01:17:02.734 --> 01:17:03.555
1.000 Instruktionen?

01:17:03.575 --> 01:17:07.118
3.000 Instruktionen?

01:17:07.158 --> 01:17:09.841
Gigahertz?

01:17:09.861 --> 01:17:11.343
Was ist Giga eigentlich?

01:17:11.363 --> 01:17:12.183
10 hoch 3?

01:17:12.223 --> 01:17:13.204
Nee, 10 hoch 6?

01:17:13.224 --> 01:17:15.427
Nee.

01:17:15.447 --> 01:17:17.849
10 hoch 9?

01:17:17.869 --> 01:17:23.695
Ja, also wir kriegen nicht nur 1.000, sondern wir kriegen mega Giga.

01:17:23.715 --> 01:17:23.815
Also,

01:17:24.672 --> 01:17:30.498
1.000 Instruktionen in einer Sekunde durch.

01:17:30.538 --> 01:17:33.542
Das heißt, ihr Programm wird vermutlich in den Bruchteil der Sekunde laufen.

01:17:35.864 --> 01:17:41.951
Die Betriebssysteme, die wir heute vor der Flinta haben, die sind alle entworfen worden in den 1970er-Jahren, 1980er-Jahren.

01:17:42.792 --> 01:17:47.777
Damals hatten die Prozessoren Taktfrequenzen zum Beispiel von 4,77 MHz.

01:17:49.023 --> 01:17:54.234
Das heißt, damals war die Sekunde viel mehr wert als heute.

01:17:54.254 --> 01:18:02.251
Und damals hat man gesagt, also bevor wir das, wenn wir ein Prozess laufen lassen, dann lassen wir den nicht länger laufen als 10 Millisekunden.

01:18:02.272 --> 01:18:04.236
Dann schalten wir um auf den nächsten.

01:18:04.256 --> 01:18:06.902
Diesen Begriff, man schaltet man um, nennt man Quantum.

01:18:06.922 --> 01:18:09.006
Man hat also dann Quantum implementiert von

01:18:09.982 --> 01:18:20.618
Millisekunden, zehn Millisekunden, das ist die Unix Zahl, Windows hat aus irgendwelchen historischen Gründen 23 Millisekunden, im Server sogar 120 Millisekunden.

01:18:20.638 --> 01:18:25.926
Also typische Prozesse brauchen halt viel weniger, einfach weil die Prozessoren so viel schneller geworden sind.

01:18:25.946 --> 01:18:31.635
Also auch da müssen wir mitzählen und wir müssen uns überlegen, wie wir damit umgehen.

01:18:35.362 --> 01:18:40.489
Und noch so viel vielleicht im Augenblick zu dem Thema Prozessor.

01:18:40.509 --> 01:18:42.312
Jetzt reden wir ganz kurz noch über ein Speicher.

01:18:42.352 --> 01:18:43.373
Wie groß ist denn ein Speicher?

01:18:43.393 --> 01:18:44.335
Was speichern wir überhaupt?

01:18:44.375 --> 01:18:46.938
Wir speichern BITs oder BITs.

01:18:46.958 --> 01:18:50.563
Ein BIT 8 BIT.

01:18:50.603 --> 01:18:52.126
Das war nicht immer so.

01:18:52.146 --> 01:18:57.353
Wenn Sie im ASCII-Code nachgucken, der American Standard Code for Information Interchange.

01:18:57.393 --> 01:18:58.194
Was ist das für ein Code?

01:18:58.214 --> 01:18:58.855
Wie viele BITs?

01:19:02.547 --> 01:19:04.331
Sieben.

01:19:04.371 --> 01:19:07.156
Und dann hatten wir den irgendwann auf acht erweitert.

01:19:07.176 --> 01:19:20.303
Die frühen Computer hatten 36 Bit und die Kleineren hatten dann zwölf Bit Verarbeitungsbreite, weil man gesagt hat, okay, da brauchen wir halt drei Instruktionen, um die 36 Bit von dem Großen zu verarbeiten.

01:19:20.283 --> 01:19:21.404
Das ist alles Geschichte.

01:19:21.444 --> 01:19:25.769
Heute hat sich eingeschwungen, man verarbeitet Bytes in Form von 8-Bits.

01:19:25.789 --> 01:19:27.851
Man redet auch von Octets.

01:19:27.871 --> 01:19:34.137
Das ist wichtig, wenn man Netzwerkprotokolle baut und Computer vernetzt, die bitte die gleichen Daten verstehen sollen.

01:19:34.177 --> 01:19:37.621
Und dann haben wir die Daumenregel nicht.

01:19:37.661 --> 01:19:44.788
10 hoch 3 ist gleich 2 hoch 10.

01:19:48.582 --> 01:19:57.633
Wann immer sie gefragt werden, in der Klausur zum Beispiel, stellen wir uns vor, wir haben einen 18-Bit-Rechner, wie viel Daten kann der verarbeiten, dann sollte Ihnen das einfallen.

01:19:57.693 --> 01:20:03.380
Das gilt natürlich nicht, sondern 10 hoch 3 ist 1000 und 2 hoch 10 ist 1024.

01:20:03.420 --> 01:20:12.971
Daher kommt auch diese Geschichte, dass man dann von Kibibytes redet und von Mabibytes und so weiter, wenn man genau die 1024, also die 2 hoch 10 als Faktor hat.

01:20:12.991 --> 01:20:18.538
Aber so als Daumenregel für einen Überschlag kann man sich einfach mal merken, 10 hoch 3 ist 2 hoch 10.

01:20:19.750 --> 01:20:24.955
Und dann weiß man, wie viele Daten ein Computer vernünftig verarbeiten kann.

01:20:24.995 --> 01:20:31.961
Damit ist auch klar, mit dem 32-Bit-Rechner können Sie wie viele Daten verarbeiten?

01:20:31.981 --> 01:20:43.692
30 ist also 2 hoch 30 ist dann 10 hoch 9, richtig?

01:20:43.712 --> 01:20:45.534
Giga, ne?

01:20:45.554 --> 01:20:48.897
Und dann haben wir 32, also 4, also 4 Gigabyte.

01:20:49.855 --> 01:21:01.858
Und das ist eine Grenze, die viele Rechner für eine lange Zeit hatten, dass man also nicht mehr als vier Gigabyte Speicher einbauen konnte in den Computer, einfach deshalb, weil es ein 32-Bit System war.

01:21:01.898 --> 01:21:04.202
Heute haben wir 64-Bit Systeme.

01:21:04.243 --> 01:21:07.348
Wie viel Speicher kann man damit erlassieren?

01:21:07.369 --> 01:21:09.473
Mehr, ja.

01:21:09.493 --> 01:21:12.859
Man muss aber herausfinden, dass diese Systeme keine 64-Bit Systeme sind.

01:21:13.143 --> 01:21:17.588
Sondern da haben die Rechner Architekten gespart und haben gesagt, 64 ist so viel, braucht kein Mensch.

01:21:18.009 --> 01:21:22.794
Wir bauen einfach nur 42-Adressleitungen hin oder 48-Adressleitungen.

01:21:22.814 --> 01:21:25.638
Das ist so ein bisschen herstellerabhängig.

01:21:25.658 --> 01:21:27.880
Mit 42, wie weit kommen wir da?

01:21:27.940 --> 01:21:29.822
Na, bis 4TB.

01:21:29.943 --> 01:21:34.768
Und 4TB ist heute gar nicht mehr so viel, sondern gibt's Systeme, die so was einfach haben.

01:21:34.788 --> 01:21:38.893
Unser größte Maschine drüben hat eine Intel-basierende Maschine mit 12TB.

01:21:38.933 --> 01:21:41.496
Wir haben Power-basierende Maschinen mit 8TB.

01:21:41.864 --> 01:21:47.149
Also ein paar Terabyte Hauptspeicher zu haben, findet man heute in Zauberndurch aus.

01:21:47.169 --> 01:21:55.538
Und also die Zahl der Adress-Bits, die spielt hier auf einmal eine Rolle.

01:21:55.558 --> 01:22:07.129
Und weil die Architektur 64-Bit Adress-Bits benutzt, heißt es noch lange nicht, dass die unterlegende Implementierung wirklich 64-Adress-Leitungen implementiert.

01:22:10.923 --> 01:22:11.444
Genau.

01:22:11.464 --> 01:22:18.460
Und jetzt gibt es hier verschiedene ... ... S.I.

01:22:18.480 --> 01:22:24.294
steht für Standard-Norm-Systemen der Einheiten.

01:22:24.334 --> 01:22:25.156
Das ist gar nicht gemeint.

01:22:26.639 --> 01:22:27.902
Sagen wir lieber nicht.

01:22:30.194 --> 01:22:34.705
Das heißt, in Übungen müssen Sie das richtig sagen.

01:22:34.725 --> 01:22:43.748
In der Klausur, na ja, da kommen es wahrscheinlich so oder so davon, aber Fakt ist, Sie sollten schon so ein bisschen mit den Zahlen jonglieren können.

01:22:46.327 --> 01:22:48.110
Was machen wir jetzt eigentlich mit Speicher?

01:22:48.130 --> 01:22:50.293
Oder wo kommt dieses Wort her?

01:22:50.513 --> 01:22:56.181
Storage ist ein Wort, was in der Mainframe geprägt wurde, was in der Mainframe tatsächlich den Hauptspeicher meint.

01:22:56.201 --> 01:22:59.866
In allen anderen Systemen meint diese gesamte Speicher Hierarchie.

01:22:59.906 --> 01:23:04.412
Und da haben wir Hauptspeicher oder Primärspeicher und dann haben wir Sekundärspeicher.

01:23:04.432 --> 01:23:08.098
Sekundärspeicher ist nicht flüchtig, Hauptspeicher ist häufig flüchtig.

01:23:08.118 --> 01:23:16.249
Und nicht flüchtiger Speicher, den können wir implementieren durch Festplatten oder durch Nonvolatile Memory in Form von Solid State Drives.

01:23:16.313 --> 01:23:19.176
Und dann haben wir sowas, eine Speicherhierarchie.

01:23:19.216 --> 01:23:21.218
Dies Bild haben Sie auch schon mal gesehen.

01:23:21.298 --> 01:23:31.668
Und was für uns hier wichtig ist, Sie haben sich primär wahrscheinlich mit diesem Abschnitt hier beschäftigt, nämlich wie kommen Daten von dem Hauptspeicher in den Prozessor.

01:23:31.708 --> 01:23:42.418
Und der Prozessor, wenn es ein moderner Riskprozessor ist, der besteht darauf, dass seine Daten alle in Registern liegen, bevor er mit Instruktion anfängt.

01:23:42.438 --> 01:23:44.160
Und dafür gehen die Instruktionen super schnell.

01:23:44.697 --> 01:23:52.034
Dafür haben sie viele Lade und Store, Lodens Store-Operationen.

01:23:52.074 --> 01:23:56.023
Ältere Prozessoren, die können auch mit Operanen agieren, die im Hauptsprecher liegen.

01:23:56.043 --> 01:24:01.896
Aber wie auch immer, wenn der Prozesse seine Instruktion ausführt, dann geht er davon aus, dass die Daten hier oben liegen.

01:24:03.074 --> 01:24:07.301
Und dieser Teil der Speicherhierarchie wird auch tatsächlich durch Hardware verwaltet.

01:24:07.902 --> 01:24:14.513
Das heißt, der Prozessor sorgt dafür, dass die Daten aus dem Hauptspeicher in den Cash baden und vom Cash in die Register.

01:24:14.553 --> 01:24:16.657
Und natürlich Register gibt es viel weniger als Cash.

01:24:16.677 --> 01:24:21.144
Das heißt, sie werden aus den Registern auch wieder verdrängt und dann geraten sie zurück in den Cash.

01:24:21.164 --> 01:24:25.992
Und der Cash ist irgendwann voll und dann werden sie wieder zurück in den Hauptspeicher verdrängt.

01:24:26.012 --> 01:24:28.997
Und diesen Teil der Geschichte macht die Hardware.

01:24:28.977 --> 01:24:46.441
Welche Daten von der Festplatte in den Speicher kommen, also das ist ja letztlich die Frage, was passiert, wenn ein Programm gestartet wird oder welche Daten von den Festplatten in den Hauptspeicher kommen, gleich in den Grünen.

01:24:46.461 --> 01:24:50.126
Das ist Aufgabe des Betriebssystems und das wird in Software gemacht.

01:24:50.146 --> 01:24:55.373
Also hier haben wir Hardware und hier haben wir Software.

01:24:59.352 --> 01:25:02.799
Und dann gibt es noch Speicher, den man heute gar nicht mehr kennt, optischen Speicher.

01:25:02.819 --> 01:25:08.050
Da gab es mal die Worms, die Ride Once, Read Many.

01:25:08.070 --> 01:25:10.876
Manche haben vielleicht von CD-RW schon mal gehört.

01:25:10.896 --> 01:25:13.101
Das sind optische Speicher.

01:25:13.121 --> 01:25:17.209
Und am Ende gibt es Bandspeicher.

01:25:22.775 --> 01:25:34.752
Wenn Sie sich hier mit Data Science beschäftigen und so eine KI-Vorlesung hören und so weiter, dann werden die Leute Ihnen erzählen, dass heute Daten schneller produziert werden, als man sie speichern kann.

01:25:35.673 --> 01:25:46.828
Tatsächlich ist es so, also wenn Sie alles das, was heute online sozusagen verarbeitet wird, speichern wollten, dann würde man mit der Produktion von SSDs und von Festplatten nicht hinterherkommen.

01:25:48.150 --> 01:25:49.592
Mit Band schafft man es dann schon.

01:25:50.146 --> 01:26:00.381
Und tatsächlich haben wir hier im HPI auch ein Band basierendes Speichersystem mit 1,7 petabyte, wo dann am Ende ein Bandroboter ist.

01:26:00.502 --> 01:26:03.606
Also hier kommt dann wieder Hardware ins Spiel beim Terzierspeicher.

01:26:03.646 --> 01:26:09.195
Sie haben das Gefühl, sie greifen einfach auf einen Freisystem zu und speichern eine Datei oder lesen die Datei.

01:26:09.235 --> 01:26:17.487
Es kann gut sein, dass die Datei inzwischen ausgelagert wurde auf ein Band und das jetzt ein paar Minuten dauert, bis dieses Band eingelegt wird.

01:26:17.922 --> 01:26:25.856
eingelesen wird, die Datei wieder im Speicher des Festplantensystems hergestellt wurde, SSD-Systems.

01:26:25.876 --> 01:26:34.310
Also Terzierspeicher, Bandspeicher ist nach wie vor das Ende der Verhandlungen, wenn es darum geht, riesige Speichermengen zu bedienen.

01:26:34.350 --> 01:26:43.626
Wenn Sie zum RWB rübergehen, dann hat der einen Teil des Archivs der ARD, was auch digital auf Bändern abgelegt wird.

01:26:45.968 --> 01:26:56.966
Zwei Begriffe, Hierarchie, je weiter wir nach oben kommen, umso schneller wird der Speicher, nach unten wird er langsamer, nach oben wird er kleiner, nach unten wird er größer, nach oben wird er teurer, nach unten wird er billiger.

01:26:57.608 --> 01:27:12.212
Das ist der eine Begriff, den haben Sie aber in GDS schon gehört, und Caching, das ist der zweite Begriff und da nehmen Sie jetzt mit, ein guter Teil davon wird ein Hardware gemacht, der Rest ist Aufgabe vom Betriebssystem, weil darüber wollten wir ja gerade mal reden.

01:27:12.192 --> 01:27:29.654
Und das sind Folien, die waren wir versteckt, habe ich hier doch wieder rausgeholt, weil ich denke, nicht am Ende reden wir über Speicher und Daten in Registern und die Frage ist, wie kommen die da hin und warum sind das die letzten, die aktuellsten Daten?

01:27:30.475 --> 01:27:37.023
Das klingt jetzt auf diesem Bild gar nicht schwer, aber wir müssen uns ja vergegen wertigen, dass wir hier von diesem Prozessor mehrere haben.

01:27:37.043 --> 01:27:41.288
Und die Frage ist, wenn der jetzt auf eine Kopie der Daten zugreift,

01:27:41.555 --> 01:27:44.879
Warum sieht man gerade die aktuelle Kopie?

01:27:44.899 --> 01:27:50.325
Also da ist noch mal eine ganze Menge Gehundschmalz dahinter in Form von solchen Cash Coherenz-Protokollen.

01:27:50.365 --> 01:27:54.529
Und auch das ist ein Bild, was ein bisschen vielleicht aus der Zeit gefallen ist.

01:27:54.549 --> 01:27:58.574
Aber trotzdem, wie groß ist denn jetzt eigentlich so ein Speichermedium?

01:27:58.594 --> 01:28:02.058
Da haben Sie selber ein Gefühl, das kennen Sie von Ihren Rechnen zu Hause.

01:28:02.078 --> 01:28:07.584
Nehmen Sie einfach mit, wenn wir über Server-Betriebssysteme reden, dann ist es alles noch mal in Größenordnung mehr.

01:28:07.624 --> 01:28:11.308
Und dann steckt da auch noch mal extra Gehundschmalz dahinter, wie man das verwaltet.

01:28:12.605 --> 01:28:25.043
Wir sind jetzt ein ganzes großes gutes Stück in der Lehrveranstaltung vorangekommen und haben vielleicht ein bisschen ein Gefühl dafür, was Betriebssysteme alles leisten und warum man die braucht.

01:28:25.063 --> 01:28:37.321
Es geht jetzt weiter, indem wir uns über Umgebungen unterhalten in den Computer zum Einsatz kommen und dann werden wir feststellen, dass es von diesem Betriebssystem schon auch Geschmacksrichtungen gibt und verschiedene Ansätze.

01:28:37.361 --> 01:28:38.843
Damit geht es aber weiter am Donnerstag.

01:28:38.863 --> 01:28:39.664
Für heute hören wir auf.

01:28:39.684 --> 01:28:40.806
Vielen Dank für die Aufmerksamkeit.

